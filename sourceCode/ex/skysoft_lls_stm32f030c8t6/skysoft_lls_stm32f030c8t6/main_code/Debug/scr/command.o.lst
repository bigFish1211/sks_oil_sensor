   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"command.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.sks_cmd_v9,"ax",%progbits
  18              		.align	1
  19              		.code	16
  20              		.thumb_func
  22              	sks_cmd_v9:
  23              	.LFB42:
  24              		.file 1 "../scr/command.c"
   1:../scr/command.c **** /*
   2:../scr/command.c ****  * report.c
   3:../scr/command.c ****  *
   4:../scr/command.c ****  *  Created on: Aug 29, 2012
   5:../scr/command.c ****  *      Author: Admin
   6:../scr/command.c ****  */
   7:../scr/command.c **** 
   8:../scr/command.c **** #include <stdio.h>
   9:../scr/command.c **** #include <stdlib.h>
  10:../scr/command.c **** #include <string.h>
  11:../scr/command.c **** #include <time.h>
  12:../scr/command.c **** #include "command.h"
  13:../scr/command.c **** #include "alarm.h"
  14:../scr/command.c **** #include "config.h"
  15:../scr/command.c **** #include "xprintf.h"
  16:../scr/command.c **** #include "Util.h"
  17:../scr/command.c **** //extern unsigned char deviceCodeMajor;
  18:../scr/command.c **** //extern unsigned long deviceCodeMinor;
  19:../scr/command.c **** 
  20:../scr/command.c **** typedef int (*SKS_CMD_HANDLER)(int from, char* command, int argc, char** argv,
  21:../scr/command.c **** 		int size, int total);
  22:../scr/command.c **** 
  23:../scr/command.c **** typedef struct _SKS_HANDLER {
  24:../scr/command.c **** 	char* cmd;
  25:../scr/command.c **** 	SKS_CMD_HANDLER handler;
  26:../scr/command.c **** 	unsigned short dis_mask; //Disable handle from source mask
  27:../scr/command.c **** 	unsigned short dis_pass; //This command can execute without pass
  28:../scr/command.c **** } SKS_HANDLER;
  29:../scr/command.c **** 
  30:../scr/command.c **** char *HexChar = "1234567890ABCDEF";
  31:../scr/command.c **** static int response = 0;
  32:../scr/command.c **** 
  33:../scr/command.c **** void turn_debug(char mark);
  34:../scr/command.c **** 
  35:../scr/command.c **** void append_int(char* str, uint8_t len, uint32_t val) {
  36:../scr/command.c **** 	uint8_t i;
  37:../scr/command.c **** 	char *ptr = str + strlen(str);
  38:../scr/command.c **** 	for (i = 1; i <= len; i++) {
  39:../scr/command.c **** 		ptr[len - i] = (uint8_t) ((val % 10UL) + '0');
  40:../scr/command.c **** 		val /= 10;
  41:../scr/command.c **** 	}
  42:../scr/command.c **** 	ptr[i - 1] = '\0';
  43:../scr/command.c **** }
  44:../scr/command.c **** 
  45:../scr/command.c **** void append_hex(char* str, uint8_t val) {
  46:../scr/command.c **** 	char *ptr = str + strlen(str);
  47:../scr/command.c **** 	ptr[0] = HexChar[val >> 4];
  48:../scr/command.c **** 	ptr[1] = HexChar[val & 0xF];
  49:../scr/command.c **** 	ptr[2] = 0;
  50:../scr/command.c **** }
  51:../scr/command.c **** 
  52:../scr/command.c **** void append_hex_long(char* str, long val) {
  53:../scr/command.c **** 	char *ptr = str + strlen(str);
  54:../scr/command.c **** 	ptr[0] = HexChar[val >> 28];
  55:../scr/command.c **** 	ptr[1] = HexChar[(val >> 24) & 0xF];
  56:../scr/command.c **** 	ptr[2] = HexChar[(val >> 20) & 0xF];
  57:../scr/command.c **** 	ptr[3] = HexChar[(val >> 16) & 0xF];
  58:../scr/command.c **** 	ptr[4] = HexChar[(val >> 12) & 0xF];
  59:../scr/command.c **** 	ptr[5] = HexChar[(val >> 8) & 0xF];
  60:../scr/command.c **** 	ptr[6] = HexChar[(val >> 4) & 0xF];
  61:../scr/command.c **** 	ptr[7] = HexChar[val & 0xF];
  62:../scr/command.c **** 	ptr[8] = 0x0;
  63:../scr/command.c **** }
  64:../scr/command.c **** 
  65:../scr/command.c **** int append_sign(char* buff) {
  66:../scr/command.c **** 	strcpy(buff, "*SS,");
  67:../scr/command.c **** 	//strcat(buff, (char*)g_config.deviceCode);
  68:../scr/command.c **** 	return 1;
  69:../scr/command.c **** }
  70:../scr/command.c **** 
  71:../scr/command.c **** int append_time(char* buff, time_t ti) {
  72:../scr/command.c **** 	time_t now = ti;
  73:../scr/command.c **** 	struct tm *tm = gmtime(&now);
  74:../scr/command.c **** 	char *ptr = buff + strlen(buff);
  75:../scr/command.c **** 	append_int(ptr, 4, tm->tm_year + 1900);
  76:../scr/command.c **** 	strcat(ptr, "-");
  77:../scr/command.c **** 	append_int(ptr, 2, tm->tm_mon + 1);
  78:../scr/command.c **** 	strcat(ptr, "-");
  79:../scr/command.c **** 	append_int(ptr, 2, tm->tm_mday);
  80:../scr/command.c **** 	strcat(ptr, " ");
  81:../scr/command.c **** 	append_int(ptr, 2, tm->tm_hour);
  82:../scr/command.c **** 	strcat(ptr, ":");
  83:../scr/command.c **** 	append_int(ptr, 2, tm->tm_min);
  84:../scr/command.c **** 	strcat(ptr, ":");
  85:../scr/command.c **** 	append_int(ptr, 2, tm->tm_sec);
  86:../scr/command.c **** 	return 1;
  87:../scr/command.c **** }
  88:../scr/command.c **** 
  89:../scr/command.c **** int append_v9_command(char *buff, char* command) {
  90:../scr/command.c **** 	strcat(buff, ",V9,");
  91:../scr/command.c **** 	strcat(buff, command);
  92:../scr/command.c **** 	return 1;
  93:../scr/command.c **** }
  94:../scr/command.c **** 
  95:../scr/command.c **** int next_char(char* data, char sep, int max) {
  96:../scr/command.c **** 	char *ptr = strchr(data, sep);
  97:../scr/command.c **** 	if (ptr) {
  98:../scr/command.c **** 		return (ptr - data) >= max ? max : (ptr - data);
  99:../scr/command.c **** 	} else {
 100:../scr/command.c **** 		return 0;
 101:../scr/command.c **** 	}
 102:../scr/command.c **** }
 103:../scr/command.c **** 
 104:../scr/command.c **** static char Response[256];
 105:../scr/command.c **** void create_v3(int blockno) {
 106:../scr/command.c **** 	append_sign(Response);
 107:../scr/command.c **** 	strcat(Response, ",V3,");
 108:../scr/command.c **** 	if (blockno >= 10000) {
 109:../scr/command.c **** 		append_int(Response, 5, blockno);
 110:../scr/command.c **** 	} else if (blockno >= 1000) {
 111:../scr/command.c **** 		append_int(Response, 4, blockno);
 112:../scr/command.c **** 	} else if (blockno >= 100) {
 113:../scr/command.c **** 		append_int(Response, 3, blockno);
 114:../scr/command.c **** 	} else if (blockno >= 10) {
 115:../scr/command.c **** 		append_int(Response, 2, blockno);
 116:../scr/command.c **** 	} else {
 117:../scr/command.c **** 		append_int(Response, 1, blockno);
 118:../scr/command.c **** 	}
 119:../scr/command.c **** }
 120:../scr/command.c **** 
 121:../scr/command.c **** int write_flash = 0;
 122:../scr/command.c **** 
 123:../scr/command.c **** extern int writeNow;
 124:../scr/command.c **** extern char tagData[68];
 125:../scr/command.c **** static int sks_cmd_write_tag(int from, char* command, int argc, char** argv,
 126:../scr/command.c **** 		int size, int total) {
 127:../scr/command.c **** 	//G9, debug setting
 128:../scr/command.c **** 	//*XX,YYYYYYYYYY,G7,HHMMSS,S#
 129:../scr/command.c **** 	char set = 0;
 130:../scr/command.c **** 	if (argv[4] == NULL)
 131:../scr/command.c **** 		return size;
 132:../scr/command.c **** 	set = atoi(argv[4]);
 133:../scr/command.c **** 	if (set == 1) {
 134:../scr/command.c **** 		xprintf("jmp set\r\n");
 135:../scr/command.c **** 		memset(tagData, 0, sizeof(tagData));
 136:../scr/command.c **** 		if (argv[5] != NULL) {
 137:../scr/command.c **** 			int len = (argv[6] - argv[5]) - 1;
 138:../scr/command.c **** 			char licenseNo[15] = { 0 };
 139:../scr/command.c **** 			unsigned int crc = 0;
 140:../scr/command.c **** 			memccpy(licenseNo, argv[5], 0, len <= 15 ? len : 15);
 141:../scr/command.c **** 			strcat(Response, licenseNo);
 142:../scr/command.c **** 			for (int i = 0; i < sizeof(licenseNo); i++) {
 143:../scr/command.c **** 				tagData[i] = licenseNo[i];
 144:../scr/command.c **** 				crc += licenseNo[i];
 145:../scr/command.c **** 			}
 146:../scr/command.c **** 			tagData[15] = (crc & 0xFF);
 147:../scr/command.c **** 		}
 148:../scr/command.c **** 
 149:../scr/command.c **** 		if (argv[6] != NULL) {
 150:../scr/command.c **** 			int len = (argv[7] - argv[6]) - 1;
 151:../scr/command.c **** 			char name[43] = { 0 };
 152:../scr/command.c **** 			memccpy(name, argv[6], 0, len <= 43 ? len : 43);
 153:../scr/command.c **** 			strcat(Response, ",");
 154:../scr/command.c **** 			strcat(Response, name);
 155:../scr/command.c **** 			unsigned int crc = 0;
 156:../scr/command.c **** 			for (int i = 0; i < sizeof(name); i++) {
 157:../scr/command.c **** 				tagData[i + 16] = name[i];
 158:../scr/command.c **** 				crc += name[i];
 159:../scr/command.c **** 			}
 160:../scr/command.c **** 			tagData[59] = (crc & 0xFF);
 161:../scr/command.c **** 		}
 162:../scr/command.c **** 
 163:../scr/command.c **** 		if (argv[7] != NULL) {
 164:../scr/command.c **** 			int len = (argv[8] - argv[7]) - 1;
 165:../scr/command.c **** 			char driverID[5] = { 0 };
 166:../scr/command.c **** 			memccpy(driverID, argv[7], 0, len <= 4 ? len : 4);
 167:../scr/command.c **** 			strcat(Response, ",");
 168:../scr/command.c **** 			strcat(Response, driverID);
 169:../scr/command.c **** 			for (int i = 0; i < sizeof(driverID); i++) {
 170:../scr/command.c **** 				tagData[i + 63] = driverID[i];
 171:../scr/command.c **** 			}
 172:../scr/command.c **** 
 173:../scr/command.c **** 			xprintf("driverID: %s, %d\r\n", driverID, len);
 174:../scr/command.c **** 		}
 175:../scr/command.c **** 
 176:../scr/command.c **** 		tagData[60] = 'S';
 177:../scr/command.c **** 		tagData[61] = 'S';
 178:../scr/command.c **** 		tagData[62] = atoi(argv[8]);
 179:../scr/command.c **** 
 180:../scr/command.c **** 		xprintf("tag data: %s", tagData);
 181:../scr/command.c **** 
 182:../scr/command.c **** 		writeNow = 1;
 183:../scr/command.c **** 	}
 184:../scr/command.c **** 
 185:../scr/command.c **** 	strcat(Response, "#\r\n");
 186:../scr/command.c **** 
 187:../scr/command.c **** 	response = 1;
 188:../scr/command.c **** 	return size;
 189:../scr/command.c **** }
 190:../scr/command.c **** 
 191:../scr/command.c **** static int sks_cmd_v9(int from, char* command, int argc, char** argv, int size,
 192:../scr/command.c **** 		int total) {
  25              		.loc 1 192 0
  26              		.cfi_startproc
  27 0000 08B5     		push	{r3, lr}
  28              	.LCFI0:
  29              		.cfi_def_cfa_offset 8
  30              		.cfi_offset 3, -8
  31              		.cfi_offset 14, -4
  32              	.LVL0:
 193:../scr/command.c **** 	//G9, debug setting
 194:../scr/command.c **** 	//*XX,YYYYYYYYYY,G7,HHMMSS,S#
 195:../scr/command.c **** 	char set = 0;
 196:../scr/command.c **** 	if (argv[4] == NULL)
  33              		.loc 1 196 0
  34 0002 1869     		ldr	r0, [r3, #16]
  35              	.LVL1:
  36 0004 0028     		cmp	r0, #0
  37 0006 04D0     		beq	.L2
 197:../scr/command.c **** 		return size;
 198:../scr/command.c **** 	set = atoi(argv[4]);
  38              		.loc 1 198 0
  39 0008 FFF7FEFF 		bl	atoi
  40              	.LVL2:
 199:../scr/command.c **** 
 200:../scr/command.c **** 	response = 0;
  41              		.loc 1 200 0
  42 000c 024B     		ldr	r3, .L3
  43 000e 0022     		mov	r2, #0
  44 0010 1A60     		str	r2, [r3]
  45              	.L2:
 201:../scr/command.c **** 	return size;
 202:../scr/command.c **** }
  46              		.loc 1 202 0
  47 0012 0298     		ldr	r0, [sp, #8]
  48              		@ sp needed for prologue
  49 0014 08BD     		pop	{r3, pc}
  50              	.L4:
  51 0016 C046     		.align	2
  52              	.L3:
  53 0018 00000000 		.word	.LANCHOR0
  54              		.cfi_endproc
  55              	.LFE42:
  57              		.section	.text.sks_cmd_write_tag,"ax",%progbits
  58              		.align	1
  59              		.code	16
  60              		.thumb_func
  62              	sks_cmd_write_tag:
  63              	.LFB41:
 126:../scr/command.c **** 		int size, int total) {
  64              		.loc 1 126 0
  65              		.cfi_startproc
  66 0000 F0B5     		push	{r4, r5, r6, r7, lr}
  67              	.LCFI1:
  68              		.cfi_def_cfa_offset 20
  69              		.cfi_offset 4, -20
  70              		.cfi_offset 5, -16
  71              		.cfi_offset 6, -12
  72              		.cfi_offset 7, -8
  73              		.cfi_offset 14, -4
  74              	.LVL3:
 130:../scr/command.c **** 	if (argv[4] == NULL)
  75              		.loc 1 130 0
  76 0002 1869     		ldr	r0, [r3, #16]
  77              	.LVL4:
 126:../scr/command.c **** 		int size, int total) {
  78              		.loc 1 126 0
  79 0004 8DB0     		sub	sp, sp, #52
  80              	.LCFI2:
  81              		.cfi_def_cfa_offset 72
 126:../scr/command.c **** 		int size, int total) {
  82              		.loc 1 126 0
  83 0006 1D1C     		mov	r5, r3
 130:../scr/command.c **** 	if (argv[4] == NULL)
  84              		.loc 1 130 0
  85 0008 0028     		cmp	r0, #0
  86 000a 00D1     		bne	.LCB57
  87 000c AAE0     		b	.L6	@long jump
  88              	.LCB57:
 132:../scr/command.c **** 	set = atoi(argv[4]);
  89              		.loc 1 132 0
  90 000e FFF7FEFF 		bl	atoi
  91              	.LVL5:
 133:../scr/command.c **** 	if (set == 1) {
  92              		.loc 1 133 0
  93 0012 C0B2     		uxtb	r0, r0
  94              	.LVL6:
  95 0014 0128     		cmp	r0, #1
  96 0016 00D0     		beq	.LCB69
  97 0018 9DE0     		b	.L7	@long jump
  98              	.LCB69:
 134:../scr/command.c **** 		xprintf("jmp set\r\n");
  99              		.loc 1 134 0
 100 001a 5448     		ldr	r0, .L18
 101 001c FFF7FEFF 		bl	xprintf
 135:../scr/command.c **** 		memset(tagData, 0, sizeof(tagData));
 102              		.loc 1 135 0
 103 0020 5348     		ldr	r0, .L18+4
 104 0022 0021     		mov	r1, #0
 105 0024 4422     		mov	r2, #68
 106 0026 FFF7FEFF 		bl	memset
 136:../scr/command.c **** 		if (argv[5] != NULL) {
 107              		.loc 1 136 0
 108 002a 6E69     		ldr	r6, [r5, #20]
 109 002c 002E     		cmp	r6, #0
 110 002e 1FD0     		beq	.L8
 111              	.LBB2:
 137:../scr/command.c **** 			int len = (argv[6] - argv[5]) - 1;
 112              		.loc 1 137 0
 113 0030 A969     		ldr	r1, [r5, #24]
 138:../scr/command.c **** 			char licenseNo[15] = { 0 };
 114              		.loc 1 138 0
 115 0032 01A8     		add	r0, sp, #4
 137:../scr/command.c **** 			int len = (argv[6] - argv[5]) - 1;
 116              		.loc 1 137 0
 117 0034 8C1B     		sub	r4, r1, r6
 118 0036 013C     		sub	r4, r4, #1
 119              	.LVL7:
 138:../scr/command.c **** 			char licenseNo[15] = { 0 };
 120              		.loc 1 138 0
 121 0038 0021     		mov	r1, #0
 122 003a 0F22     		mov	r2, #15
 123 003c FFF7FEFF 		bl	memset
 124              	.LVL8:
 140:../scr/command.c **** 			memccpy(licenseNo, argv[5], 0, len <= 15 ? len : 15);
 125              		.loc 1 140 0
 126 0040 231C     		mov	r3, r4
 127 0042 0F2C     		cmp	r4, #15
 128 0044 00DD     		ble	.L9
 129 0046 0F23     		mov	r3, #15
 130              	.L9:
 131 0048 0022     		mov	r2, #0
 132 004a 311C     		mov	r1, r6
 133 004c 01A8     		add	r0, sp, #4
 134 004e FFF7FEFF 		bl	memccpy
 141:../scr/command.c **** 			strcat(Response, licenseNo);
 135              		.loc 1 141 0
 136 0052 4848     		ldr	r0, .L18+8
 137 0054 01A9     		add	r1, sp, #4
 138 0056 FFF7FEFF 		bl	strcat
 139              	.LVL9:
 142:../scr/command.c **** 			for (int i = 0; i < sizeof(licenseNo); i++) {
 140              		.loc 1 142 0
 141 005a 0023     		mov	r3, #0
 139:../scr/command.c **** 			unsigned int crc = 0;
 142              		.loc 1 139 0
 143 005c 1A1C     		mov	r2, r3
 144              	.LVL10:
 145              	.L10:
 146              	.LBB3:
 143:../scr/command.c **** 				tagData[i] = licenseNo[i];
 147              		.loc 1 143 0 discriminator 2
 148 005e 01AF     		add	r7, sp, #4
 149 0060 DE5D     		ldrb	r6, [r3, r7]
 150 0062 4349     		ldr	r1, .L18+4
 144:../scr/command.c **** 				crc += licenseNo[i];
 151              		.loc 1 144 0 discriminator 2
 152 0064 9219     		add	r2, r2, r6
 153              	.LVL11:
 143:../scr/command.c **** 				tagData[i] = licenseNo[i];
 154              		.loc 1 143 0 discriminator 2
 155 0066 CE54     		strb	r6, [r1, r3]
 142:../scr/command.c **** 			for (int i = 0; i < sizeof(licenseNo); i++) {
 156              		.loc 1 142 0 discriminator 2
 157 0068 0133     		add	r3, r3, #1
 158              	.LVL12:
 159 006a 0F2B     		cmp	r3, #15
 160 006c F7D1     		bne	.L10
 161              	.LBE3:
 146:../scr/command.c **** 			tagData[15] = (crc & 0xFF);
 162              		.loc 1 146 0
 163 006e CA73     		strb	r2, [r1, #15]
 164              	.LVL13:
 165              	.L8:
 166              	.LBE2:
 149:../scr/command.c **** 		if (argv[6] != NULL) {
 167              		.loc 1 149 0
 168 0070 AE69     		ldr	r6, [r5, #24]
 169 0072 002E     		cmp	r6, #0
 170 0074 26D0     		beq	.L11
 171              	.LBB4:
 150:../scr/command.c **** 			int len = (argv[7] - argv[6]) - 1;
 172              		.loc 1 150 0
 173 0076 EA69     		ldr	r2, [r5, #28]
 151:../scr/command.c **** 			char name[43] = { 0 };
 174              		.loc 1 151 0
 175 0078 01A8     		add	r0, sp, #4
 150:../scr/command.c **** 			int len = (argv[7] - argv[6]) - 1;
 176              		.loc 1 150 0
 177 007a 941B     		sub	r4, r2, r6
 178 007c 013C     		sub	r4, r4, #1
 179              	.LVL14:
 151:../scr/command.c **** 			char name[43] = { 0 };
 180              		.loc 1 151 0
 181 007e 0021     		mov	r1, #0
 182 0080 2B22     		mov	r2, #43
 183 0082 FFF7FEFF 		bl	memset
 152:../scr/command.c **** 			memccpy(name, argv[6], 0, len <= 43 ? len : 43);
 184              		.loc 1 152 0
 185 0086 231C     		mov	r3, r4
 186 0088 2B2C     		cmp	r4, #43
 187 008a 00DD     		ble	.L12
 188 008c 2B23     		mov	r3, #43
 189              	.L12:
 190 008e 0022     		mov	r2, #0
 191 0090 311C     		mov	r1, r6
 192 0092 01A8     		add	r0, sp, #4
 193 0094 FFF7FEFF 		bl	memccpy
 153:../scr/command.c **** 			strcat(Response, ",");
 194              		.loc 1 153 0
 195 0098 364E     		ldr	r6, .L18+8
 196 009a 3749     		ldr	r1, .L18+12
 197 009c 301C     		mov	r0, r6
 198 009e FFF7FEFF 		bl	strcat
 154:../scr/command.c **** 			strcat(Response, name);
 199              		.loc 1 154 0
 200 00a2 301C     		mov	r0, r6
 201 00a4 01A9     		add	r1, sp, #4
 202 00a6 FFF7FEFF 		bl	strcat
 203              	.LVL15:
 156:../scr/command.c **** 			for (int i = 0; i < sizeof(name); i++) {
 204              		.loc 1 156 0
 205 00aa 0023     		mov	r3, #0
 155:../scr/command.c **** 			unsigned int crc = 0;
 206              		.loc 1 155 0
 207 00ac 1A1C     		mov	r2, r3
 208              	.LVL16:
 209              	.L13:
 210              	.LBB5:
 157:../scr/command.c **** 				tagData[i + 16] = name[i];
 211              		.loc 1 157 0 discriminator 2
 212 00ae 01A9     		add	r1, sp, #4
 213 00b0 585C     		ldrb	r0, [r3, r1]
 125:../scr/command.c **** static int sks_cmd_write_tag(int from, char* command, int argc, char** argv,
 214              		.loc 1 125 0 discriminator 2
 215 00b2 2F49     		ldr	r1, .L18+4
 158:../scr/command.c **** 				crc += name[i];
 216              		.loc 1 158 0 discriminator 2
 217 00b4 1218     		add	r2, r2, r0
 218              	.LVL17:
 125:../scr/command.c **** static int sks_cmd_write_tag(int from, char* command, int argc, char** argv,
 219              		.loc 1 125 0 discriminator 2
 220 00b6 5F18     		add	r7, r3, r1
 156:../scr/command.c **** 			for (int i = 0; i < sizeof(name); i++) {
 221              		.loc 1 156 0 discriminator 2
 222 00b8 0133     		add	r3, r3, #1
 223              	.LVL18:
 157:../scr/command.c **** 				tagData[i + 16] = name[i];
 224              		.loc 1 157 0 discriminator 2
 225 00ba 3874     		strb	r0, [r7, #16]
 156:../scr/command.c **** 			for (int i = 0; i < sizeof(name); i++) {
 226              		.loc 1 156 0 discriminator 2
 227 00bc 2B2B     		cmp	r3, #43
 228 00be F6D1     		bne	.L13
 229              	.LBE5:
 160:../scr/command.c **** 			tagData[59] = (crc & 0xFF);
 230              		.loc 1 160 0
 231 00c0 3B31     		add	r1, r1, #59
 232 00c2 0A70     		strb	r2, [r1]
 233              	.LVL19:
 234              	.L11:
 235              	.LBE4:
 163:../scr/command.c **** 		if (argv[7] != NULL) {
 236              		.loc 1 163 0
 237 00c4 E969     		ldr	r1, [r5, #28]
 238 00c6 0029     		cmp	r1, #0
 239 00c8 30D0     		beq	.L14
 240              	.LBB6:
 164:../scr/command.c **** 			int len = (argv[8] - argv[7]) - 1;
 241              		.loc 1 164 0
 242 00ca 2C6A     		ldr	r4, [r5, #32]
 165:../scr/command.c **** 			char driverID[5] = { 0 };
 243              		.loc 1 165 0
 244 00cc 0023     		mov	r3, #0
 164:../scr/command.c **** 			int len = (argv[8] - argv[7]) - 1;
 245              		.loc 1 164 0
 246 00ce 661A     		sub	r6, r4, r1
 247 00d0 013E     		sub	r6, r6, #1
 248              	.LVL20:
 165:../scr/command.c **** 			char driverID[5] = { 0 };
 249              		.loc 1 165 0
 250 00d2 01A8     		add	r0, sp, #4
 251 00d4 0193     		str	r3, [sp, #4]
 252 00d6 0371     		strb	r3, [r0, #4]
 166:../scr/command.c **** 			memccpy(driverID, argv[7], 0, len <= 4 ? len : 4);
 253              		.loc 1 166 0
 254 00d8 331C     		mov	r3, r6
 255 00da 042E     		cmp	r6, #4
 256 00dc 00DD     		ble	.L15
 257 00de 0423     		mov	r3, #4
 258              	.L15:
 259 00e0 0022     		mov	r2, #0
 260 00e2 FFF7FEFF 		bl	memccpy
 167:../scr/command.c **** 			strcat(Response, ",");
 261              		.loc 1 167 0
 262 00e6 234F     		ldr	r7, .L18+8
 168:../scr/command.c **** 			strcat(Response, driverID);
 263              		.loc 1 168 0
 264 00e8 01AC     		add	r4, sp, #4
 167:../scr/command.c **** 			strcat(Response, ",");
 265              		.loc 1 167 0
 266 00ea 381C     		mov	r0, r7
 267 00ec 2249     		ldr	r1, .L18+12
 268 00ee FFF7FEFF 		bl	strcat
 168:../scr/command.c **** 			strcat(Response, driverID);
 269              		.loc 1 168 0
 270 00f2 381C     		mov	r0, r7
 271 00f4 211C     		mov	r1, r4
 272 00f6 FFF7FEFF 		bl	strcat
 273              	.LVL21:
 274              	.LBB7:
 170:../scr/command.c **** 				tagData[i + 63] = driverID[i];
 275              		.loc 1 170 0
 276 00fa 1D48     		ldr	r0, .L18+4
 277 00fc 2378     		ldrb	r3, [r4]
 278 00fe 021C     		mov	r2, r0
 279 0100 3F32     		add	r2, r2, #63
 280 0102 1370     		strb	r3, [r2]
 281              	.LVL22:
 282 0104 6778     		ldrb	r7, [r4, #1]
 283 0106 011C     		mov	r1, r0
 284 0108 4031     		add	r1, r1, #64
 285 010a 0F70     		strb	r7, [r1]
 286              	.LVL23:
 287 010c A378     		ldrb	r3, [r4, #2]
 288 010e 021C     		mov	r2, r0
 289 0110 4132     		add	r2, r2, #65
 290 0112 1370     		strb	r3, [r2]
 291              	.LVL24:
 292 0114 011C     		mov	r1, r0
 293 0116 E778     		ldrb	r7, [r4, #3]
 294 0118 4231     		add	r1, r1, #66
 295 011a 0F70     		strb	r7, [r1]
 296              	.LVL25:
 297 011c 2279     		ldrb	r2, [r4, #4]
 298 011e 4330     		add	r0, r0, #67
 299 0120 0270     		strb	r2, [r0]
 300              	.LVL26:
 301              	.LBE7:
 173:../scr/command.c **** 			xprintf("driverID: %s, %d\r\n", driverID, len);
 302              		.loc 1 173 0
 303 0122 211C     		mov	r1, r4
 304 0124 1548     		ldr	r0, .L18+16
 305 0126 321C     		mov	r2, r6
 306 0128 FFF7FEFF 		bl	xprintf
 307              	.LVL27:
 308              	.L14:
 309              	.LBE6:
 176:../scr/command.c **** 		tagData[60] = 'S';
 310              		.loc 1 176 0
 311 012c 104C     		ldr	r4, .L18+4
 312 012e 5323     		mov	r3, #83
 313 0130 221C     		mov	r2, r4
 177:../scr/command.c **** 		tagData[61] = 'S';
 314              		.loc 1 177 0
 315 0132 201C     		mov	r0, r4
 176:../scr/command.c **** 		tagData[60] = 'S';
 316              		.loc 1 176 0
 317 0134 3C32     		add	r2, r2, #60
 177:../scr/command.c **** 		tagData[61] = 'S';
 318              		.loc 1 177 0
 319 0136 3D30     		add	r0, r0, #61
 176:../scr/command.c **** 		tagData[60] = 'S';
 320              		.loc 1 176 0
 321 0138 1370     		strb	r3, [r2]
 177:../scr/command.c **** 		tagData[61] = 'S';
 322              		.loc 1 177 0
 323 013a 0370     		strb	r3, [r0]
 178:../scr/command.c **** 		tagData[62] = atoi(argv[8]);
 324              		.loc 1 178 0
 325 013c 286A     		ldr	r0, [r5, #32]
 326 013e FFF7FEFF 		bl	atoi
 327 0142 211C     		mov	r1, r4
 328 0144 3E31     		add	r1, r1, #62
 329 0146 0870     		strb	r0, [r1]
 180:../scr/command.c **** 		xprintf("tag data: %s", tagData);
 330              		.loc 1 180 0
 331 0148 0D48     		ldr	r0, .L18+20
 332 014a 211C     		mov	r1, r4
 333 014c FFF7FEFF 		bl	xprintf
 182:../scr/command.c **** 		writeNow = 1;
 334              		.loc 1 182 0
 335 0150 0C4E     		ldr	r6, .L18+24
 336 0152 0125     		mov	r5, #1
 337              	.LVL28:
 338 0154 3560     		str	r5, [r6]
 339              	.L7:
 185:../scr/command.c **** 	strcat(Response, "#\r\n");
 340              		.loc 1 185 0
 341 0156 0748     		ldr	r0, .L18+8
 342 0158 0B49     		ldr	r1, .L18+28
 343 015a FFF7FEFF 		bl	strcat
 187:../scr/command.c **** 	response = 1;
 344              		.loc 1 187 0
 345 015e 0B4D     		ldr	r5, .L18+32
 346 0160 0127     		mov	r7, #1
 347 0162 2F60     		str	r7, [r5]
 348              	.L6:
 189:../scr/command.c **** }
 349              		.loc 1 189 0
 350 0164 1298     		ldr	r0, [sp, #72]
 351 0166 0DB0     		add	sp, sp, #52
 352              		@ sp needed for prologue
 353 0168 F0BD     		pop	{r4, r5, r6, r7, pc}
 354              	.L19:
 355 016a C046     		.align	2
 356              	.L18:
 357 016c 00000000 		.word	.LC3
 358 0170 00000000 		.word	tagData
 359 0174 00000000 		.word	.LANCHOR1
 360 0178 0A000000 		.word	.LC7
 361 017c 0C000000 		.word	.LC9
 362 0180 1F000000 		.word	.LC11
 363 0184 00000000 		.word	writeNow
 364 0188 2C000000 		.word	.LC14
 365 018c 00000000 		.word	.LANCHOR0
 366              		.cfi_endproc
 367              	.LFE41:
 369              		.global	__aeabi_uidivmod
 370              		.global	__aeabi_uidiv
 371              		.section	.text.append_int,"ax",%progbits
 372              		.align	1
 373              		.global	append_int
 374              		.code	16
 375              		.thumb_func
 377              	append_int:
 378              	.LFB33:
  35:../scr/command.c **** void append_int(char* str, uint8_t len, uint32_t val) {
 379              		.loc 1 35 0
 380              		.cfi_startproc
 381 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 382              	.LCFI3:
 383              		.cfi_def_cfa_offset 32
 384              		.cfi_offset 0, -32
 385              		.cfi_offset 1, -28
 386              		.cfi_offset 2, -24
 387              		.cfi_offset 4, -20
 388              		.cfi_offset 5, -16
 389              		.cfi_offset 6, -12
 390              		.cfi_offset 7, -8
 391              		.cfi_offset 14, -4
 392              	.LVL29:
  35:../scr/command.c **** void append_int(char* str, uint8_t len, uint32_t val) {
 393              		.loc 1 35 0
 394 0002 041C     		mov	r4, r0
 395 0004 0F1C     		mov	r7, r1
 396 0006 151C     		mov	r5, r2
  37:../scr/command.c **** 	char *ptr = str + strlen(str);
 397              		.loc 1 37 0
 398 0008 FFF7FEFF 		bl	strlen
 399              	.LVL30:
 400 000c 2618     		add	r6, r4, r0
 401              	.LVL31:
  38:../scr/command.c **** 	for (i = 1; i <= len; i++) {
 402              		.loc 1 38 0
 403 000e 0124     		mov	r4, #1
 404              	.LVL32:
 405 0010 0FE0     		b	.L21
 406              	.LVL33:
 407              	.L22:
  39:../scr/command.c **** 		ptr[len - i] = (uint8_t) ((val % 10UL) + '0');
 408              		.loc 1 39 0 discriminator 2
 409 0012 381B     		sub	r0, r7, r4
 410 0014 0190     		str	r0, [sp, #4]
 411 0016 0A21     		mov	r1, #10
 412 0018 281C     		mov	r0, r5
 413 001a FFF7FEFF 		bl	__aeabi_uidivmod
 414 001e 019B     		ldr	r3, [sp, #4]
 415 0020 3031     		add	r1, r1, #48
 416 0022 F154     		strb	r1, [r6, r3]
  40:../scr/command.c **** 		val /= 10;
 417              		.loc 1 40 0 discriminator 2
 418 0024 281C     		mov	r0, r5
 419 0026 0A21     		mov	r1, #10
 420 0028 FFF7FEFF 		bl	__aeabi_uidiv
  38:../scr/command.c **** 	for (i = 1; i <= len; i++) {
 421              		.loc 1 38 0 discriminator 2
 422 002c 0134     		add	r4, r4, #1
 423              	.LVL34:
  40:../scr/command.c **** 		val /= 10;
 424              		.loc 1 40 0 discriminator 2
 425 002e 051C     		mov	r5, r0
 426              	.LVL35:
  38:../scr/command.c **** 	for (i = 1; i <= len; i++) {
 427              		.loc 1 38 0 discriminator 2
 428 0030 E4B2     		uxtb	r4, r4
 429              	.LVL36:
 430              	.L21:
  38:../scr/command.c **** 	for (i = 1; i <= len; i++) {
 431              		.loc 1 38 0 is_stmt 0 discriminator 1
 432 0032 BC42     		cmp	r4, r7
 433 0034 EDD9     		bls	.L22
  42:../scr/command.c **** 	ptr[i - 1] = '\0';
 434              		.loc 1 42 0 is_stmt 1
 435 0036 3219     		add	r2, r6, r4
 436 0038 013A     		sub	r2, r2, #1
 437 003a 0021     		mov	r1, #0
 438 003c 1170     		strb	r1, [r2]
 439              		@ sp needed for prologue
 440              	.LVL37:
 441              	.LVL38:
 442              	.LVL39:
  43:../scr/command.c **** }
 443              		.loc 1 43 0
 444 003e F7BD     		pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 445              		.cfi_endproc
 446              	.LFE33:
 448              		.section	.text.append_hex,"ax",%progbits
 449              		.align	1
 450              		.global	append_hex
 451              		.code	16
 452              		.thumb_func
 454              	append_hex:
 455              	.LFB34:
  45:../scr/command.c **** void append_hex(char* str, uint8_t val) {
 456              		.loc 1 45 0
 457              		.cfi_startproc
 458 0000 38B5     		push	{r3, r4, r5, lr}
 459              	.LCFI4:
 460              		.cfi_def_cfa_offset 16
 461              		.cfi_offset 3, -16
 462              		.cfi_offset 4, -12
 463              		.cfi_offset 5, -8
 464              		.cfi_offset 14, -4
 465              	.LVL40:
  45:../scr/command.c **** void append_hex(char* str, uint8_t val) {
 466              		.loc 1 45 0
 467 0002 0D1C     		mov	r5, r1
 468 0004 041C     		mov	r4, r0
  46:../scr/command.c **** 	char *ptr = str + strlen(str);
 469              		.loc 1 46 0
 470 0006 FFF7FEFF 		bl	strlen
 471              	.LVL41:
  47:../scr/command.c **** 	ptr[0] = HexChar[val >> 4];
 472              		.loc 1 47 0
 473 000a 074B     		ldr	r3, .L24
 474 000c 2A09     		lsr	r2, r5, #4
 475 000e 1968     		ldr	r1, [r3]
  46:../scr/command.c **** 	char *ptr = str + strlen(str);
 476              		.loc 1 46 0
 477 0010 2418     		add	r4, r4, r0
 478              	.LVL42:
  47:../scr/command.c **** 	ptr[0] = HexChar[val >> 4];
 479              		.loc 1 47 0
 480 0012 885C     		ldrb	r0, [r1, r2]
  48:../scr/command.c **** 	ptr[1] = HexChar[val & 0xF];
 481              		.loc 1 48 0
 482 0014 0F22     		mov	r2, #15
  47:../scr/command.c **** 	ptr[0] = HexChar[val >> 4];
 483              		.loc 1 47 0
 484 0016 2070     		strb	r0, [r4]
  48:../scr/command.c **** 	ptr[1] = HexChar[val & 0xF];
 485              		.loc 1 48 0
 486 0018 1968     		ldr	r1, [r3]
 487 001a 1540     		and	r5, r2
 488 001c 485D     		ldrb	r0, [r1, r5]
  49:../scr/command.c **** 	ptr[2] = 0;
 489              		.loc 1 49 0
 490 001e 0023     		mov	r3, #0
  48:../scr/command.c **** 	ptr[1] = HexChar[val & 0xF];
 491              		.loc 1 48 0
 492 0020 6070     		strb	r0, [r4, #1]
  49:../scr/command.c **** 	ptr[2] = 0;
 493              		.loc 1 49 0
 494 0022 A370     		strb	r3, [r4, #2]
 495              		@ sp needed for prologue
 496              	.LVL43:
  50:../scr/command.c **** }
 497              		.loc 1 50 0
 498 0024 38BD     		pop	{r3, r4, r5, pc}
 499              	.L25:
 500 0026 C046     		.align	2
 501              	.L24:
 502 0028 00000000 		.word	.LANCHOR2
 503              		.cfi_endproc
 504              	.LFE34:
 506              		.section	.text.append_hex_long,"ax",%progbits
 507              		.align	1
 508              		.global	append_hex_long
 509              		.code	16
 510              		.thumb_func
 512              	append_hex_long:
 513              	.LFB35:
  52:../scr/command.c **** void append_hex_long(char* str, long val) {
 514              		.loc 1 52 0
 515              		.cfi_startproc
 516 0000 38B5     		push	{r3, r4, r5, lr}
 517              	.LCFI5:
 518              		.cfi_def_cfa_offset 16
 519              		.cfi_offset 3, -16
 520              		.cfi_offset 4, -12
 521              		.cfi_offset 5, -8
 522              		.cfi_offset 14, -4
 523              	.LVL44:
  52:../scr/command.c **** void append_hex_long(char* str, long val) {
 524              		.loc 1 52 0
 525 0002 0D1C     		mov	r5, r1
 526 0004 041C     		mov	r4, r0
  53:../scr/command.c **** 	char *ptr = str + strlen(str);
 527              		.loc 1 53 0
 528 0006 FFF7FEFF 		bl	strlen
 529              	.LVL45:
  54:../scr/command.c **** 	ptr[0] = HexChar[val >> 28];
 530              		.loc 1 54 0
 531 000a 144A     		ldr	r2, .L27
  53:../scr/command.c **** 	char *ptr = str + strlen(str);
 532              		.loc 1 53 0
 533 000c 2418     		add	r4, r4, r0
 534              	.LVL46:
  54:../scr/command.c **** 	ptr[0] = HexChar[val >> 28];
 535              		.loc 1 54 0
 536 000e 1168     		ldr	r1, [r2]
 537 0010 2817     		asr	r0, r5, #28
 538 0012 0B5C     		ldrb	r3, [r1, r0]
  55:../scr/command.c **** 	ptr[1] = HexChar[(val >> 24) & 0xF];
 539              		.loc 1 55 0
 540 0014 2916     		asr	r1, r5, #24
  54:../scr/command.c **** 	ptr[0] = HexChar[val >> 28];
 541              		.loc 1 54 0
 542 0016 2370     		strb	r3, [r4]
  55:../scr/command.c **** 	ptr[1] = HexChar[(val >> 24) & 0xF];
 543              		.loc 1 55 0
 544 0018 1068     		ldr	r0, [r2]
 545 001a 0F23     		mov	r3, #15
 546 001c 1940     		and	r1, r3
 547 001e 415C     		ldrb	r1, [r0, r1]
 548              		@ sp needed for prologue
 549 0020 6170     		strb	r1, [r4, #1]
  56:../scr/command.c **** 	ptr[2] = HexChar[(val >> 20) & 0xF];
 550              		.loc 1 56 0
 551 0022 1068     		ldr	r0, [r2]
 552 0024 2915     		asr	r1, r5, #20
 553 0026 1940     		and	r1, r3
 554 0028 415C     		ldrb	r1, [r0, r1]
 555 002a A170     		strb	r1, [r4, #2]
  57:../scr/command.c **** 	ptr[3] = HexChar[(val >> 16) & 0xF];
 556              		.loc 1 57 0
 557 002c 1068     		ldr	r0, [r2]
 558 002e 2914     		asr	r1, r5, #16
 559 0030 1940     		and	r1, r3
 560 0032 415C     		ldrb	r1, [r0, r1]
  58:../scr/command.c **** 	ptr[4] = HexChar[(val >> 12) & 0xF];
 561              		.loc 1 58 0
 562 0034 2813     		asr	r0, r5, #12
  57:../scr/command.c **** 	ptr[3] = HexChar[(val >> 16) & 0xF];
 563              		.loc 1 57 0
 564 0036 E170     		strb	r1, [r4, #3]
  58:../scr/command.c **** 	ptr[4] = HexChar[(val >> 12) & 0xF];
 565              		.loc 1 58 0
 566 0038 1268     		ldr	r2, [r2]
 567 003a 1840     		and	r0, r3
 568 003c 115C     		ldrb	r1, [r2, r0]
  59:../scr/command.c **** 	ptr[5] = HexChar[(val >> 8) & 0xF];
 569              		.loc 1 59 0
 570 003e 2812     		asr	r0, r5, #8
  58:../scr/command.c **** 	ptr[4] = HexChar[(val >> 12) & 0xF];
 571              		.loc 1 58 0
 572 0040 2171     		strb	r1, [r4, #4]
  59:../scr/command.c **** 	ptr[5] = HexChar[(val >> 8) & 0xF];
 573              		.loc 1 59 0
 574 0042 1840     		and	r0, r3
 575 0044 115C     		ldrb	r1, [r2, r0]
  60:../scr/command.c **** 	ptr[6] = HexChar[(val >> 4) & 0xF];
 576              		.loc 1 60 0
 577 0046 2811     		asr	r0, r5, #4
  59:../scr/command.c **** 	ptr[5] = HexChar[(val >> 8) & 0xF];
 578              		.loc 1 59 0
 579 0048 6171     		strb	r1, [r4, #5]
  60:../scr/command.c **** 	ptr[6] = HexChar[(val >> 4) & 0xF];
 580              		.loc 1 60 0
 581 004a 1840     		and	r0, r3
 582 004c 115C     		ldrb	r1, [r2, r0]
  61:../scr/command.c **** 	ptr[7] = HexChar[val & 0xF];
 583              		.loc 1 61 0
 584 004e 1D40     		and	r5, r3
 585              	.LVL47:
  60:../scr/command.c **** 	ptr[6] = HexChar[(val >> 4) & 0xF];
 586              		.loc 1 60 0
 587 0050 A171     		strb	r1, [r4, #6]
  61:../scr/command.c **** 	ptr[7] = HexChar[val & 0xF];
 588              		.loc 1 61 0
 589 0052 505D     		ldrb	r0, [r2, r5]
  62:../scr/command.c **** 	ptr[8] = 0x0;
 590              		.loc 1 62 0
 591 0054 0023     		mov	r3, #0
  61:../scr/command.c **** 	ptr[7] = HexChar[val & 0xF];
 592              		.loc 1 61 0
 593 0056 E071     		strb	r0, [r4, #7]
  62:../scr/command.c **** 	ptr[8] = 0x0;
 594              		.loc 1 62 0
 595 0058 2372     		strb	r3, [r4, #8]
 596              	.LVL48:
  63:../scr/command.c **** }
 597              		.loc 1 63 0
 598 005a 38BD     		pop	{r3, r4, r5, pc}
 599              	.L28:
 600              		.align	2
 601              	.L27:
 602 005c 00000000 		.word	.LANCHOR2
 603              		.cfi_endproc
 604              	.LFE35:
 606              		.section	.text.append_sign,"ax",%progbits
 607              		.align	1
 608              		.global	append_sign
 609              		.code	16
 610              		.thumb_func
 612              	append_sign:
 613              	.LFB36:
  65:../scr/command.c **** int append_sign(char* buff) {
 614              		.loc 1 65 0
 615              		.cfi_startproc
 616 0000 08B5     		push	{r3, lr}
 617              	.LCFI6:
 618              		.cfi_def_cfa_offset 8
 619              		.cfi_offset 3, -8
 620              		.cfi_offset 14, -4
 621              	.LVL49:
  66:../scr/command.c **** 	strcpy(buff, "*SS,");
 622              		.loc 1 66 0
 623 0002 0249     		ldr	r1, .L30
 624 0004 FFF7FEFF 		bl	strcpy
 625              	.LVL50:
 626              		@ sp needed for prologue
  69:../scr/command.c **** }
 627              		.loc 1 69 0
 628 0008 0120     		mov	r0, #1
 629 000a 08BD     		pop	{r3, pc}
 630              	.L31:
 631              		.align	2
 632              	.L30:
 633 000c 30000000 		.word	.LC28
 634              		.cfi_endproc
 635              	.LFE36:
 637              		.section	.text.append_time,"ax",%progbits
 638              		.align	1
 639              		.global	append_time
 640              		.code	16
 641              		.thumb_func
 643              	append_time:
 644              	.LFB37:
  71:../scr/command.c **** int append_time(char* buff, time_t ti) {
 645              		.loc 1 71 0
 646              		.cfi_startproc
 647 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 648              	.LCFI7:
 649              		.cfi_def_cfa_offset 24
 650              		.cfi_offset 0, -24
 651              		.cfi_offset 1, -20
 652              		.cfi_offset 4, -16
 653              		.cfi_offset 5, -12
 654              		.cfi_offset 6, -8
 655              		.cfi_offset 14, -4
 656              	.LVL51:
  71:../scr/command.c **** int append_time(char* buff, time_t ti) {
 657              		.loc 1 71 0
 658 0002 051C     		mov	r5, r0
  73:../scr/command.c **** 	struct tm *tm = gmtime(&now);
 659              		.loc 1 73 0
 660 0004 01A8     		add	r0, sp, #4
 661              	.LVL52:
  72:../scr/command.c **** 	time_t now = ti;
 662              		.loc 1 72 0
 663 0006 0191     		str	r1, [sp, #4]
 664              	.LVL53:
  73:../scr/command.c **** 	struct tm *tm = gmtime(&now);
 665              		.loc 1 73 0
 666 0008 FFF7FEFF 		bl	gmtime
 667              	.LVL54:
 668 000c 041C     		mov	r4, r0
 669              	.LVL55:
  74:../scr/command.c **** 	char *ptr = buff + strlen(buff);
 670              		.loc 1 74 0
 671 000e 281C     		mov	r0, r5
 672              	.LVL56:
 673 0010 FFF7FEFF 		bl	strlen
  75:../scr/command.c **** 	append_int(ptr, 4, tm->tm_year + 1900);
 674              		.loc 1 75 0
 675 0014 1C4B     		ldr	r3, .L33
 676 0016 6269     		ldr	r2, [r4, #20]
  74:../scr/command.c **** 	char *ptr = buff + strlen(buff);
 677              		.loc 1 74 0
 678 0018 2D18     		add	r5, r5, r0
 679              	.LVL57:
  75:../scr/command.c **** 	append_int(ptr, 4, tm->tm_year + 1900);
 680              		.loc 1 75 0
 681 001a D218     		add	r2, r2, r3
 682 001c 281C     		mov	r0, r5
 683 001e 0421     		mov	r1, #4
 684 0020 FFF7FEFF 		bl	append_int
  76:../scr/command.c **** 	strcat(ptr, "-");
 685              		.loc 1 76 0
 686 0024 194E     		ldr	r6, .L33+4
 687 0026 281C     		mov	r0, r5
 688 0028 311C     		mov	r1, r6
 689 002a FFF7FEFF 		bl	strcat
  77:../scr/command.c **** 	append_int(ptr, 2, tm->tm_mon + 1);
 690              		.loc 1 77 0
 691 002e 2269     		ldr	r2, [r4, #16]
 692 0030 281C     		mov	r0, r5
 693 0032 0132     		add	r2, r2, #1
 694 0034 0221     		mov	r1, #2
 695 0036 FFF7FEFF 		bl	append_int
  78:../scr/command.c **** 	strcat(ptr, "-");
 696              		.loc 1 78 0
 697 003a 281C     		mov	r0, r5
 698 003c 311C     		mov	r1, r6
 699 003e FFF7FEFF 		bl	strcat
  79:../scr/command.c **** 	append_int(ptr, 2, tm->tm_mday);
 700              		.loc 1 79 0
 701 0042 281C     		mov	r0, r5
 702 0044 E268     		ldr	r2, [r4, #12]
 703 0046 0221     		mov	r1, #2
 704 0048 FFF7FEFF 		bl	append_int
  80:../scr/command.c **** 	strcat(ptr, " ");
 705              		.loc 1 80 0
 706 004c 281C     		mov	r0, r5
 707 004e 1049     		ldr	r1, .L33+8
 708 0050 FFF7FEFF 		bl	strcat
  81:../scr/command.c **** 	append_int(ptr, 2, tm->tm_hour);
 709              		.loc 1 81 0
 710 0054 281C     		mov	r0, r5
 711 0056 A268     		ldr	r2, [r4, #8]
 712 0058 0221     		mov	r1, #2
 713 005a FFF7FEFF 		bl	append_int
  82:../scr/command.c **** 	strcat(ptr, ":");
 714              		.loc 1 82 0
 715 005e 0D4E     		ldr	r6, .L33+12
 716 0060 281C     		mov	r0, r5
 717 0062 311C     		mov	r1, r6
 718 0064 FFF7FEFF 		bl	strcat
  83:../scr/command.c **** 	append_int(ptr, 2, tm->tm_min);
 719              		.loc 1 83 0
 720 0068 281C     		mov	r0, r5
 721 006a 6268     		ldr	r2, [r4, #4]
 722 006c 0221     		mov	r1, #2
 723 006e FFF7FEFF 		bl	append_int
  84:../scr/command.c **** 	strcat(ptr, ":");
 724              		.loc 1 84 0
 725 0072 311C     		mov	r1, r6
 726 0074 281C     		mov	r0, r5
 727 0076 FFF7FEFF 		bl	strcat
  85:../scr/command.c **** 	append_int(ptr, 2, tm->tm_sec);
 728              		.loc 1 85 0
 729 007a 281C     		mov	r0, r5
 730 007c 0221     		mov	r1, #2
 731 007e 2268     		ldr	r2, [r4]
 732 0080 FFF7FEFF 		bl	append_int
 733              		@ sp needed for prologue
  87:../scr/command.c **** }
 734              		.loc 1 87 0
 735 0084 0120     		mov	r0, #1
 736              	.LVL58:
 737              	.LVL59:
 738 0086 76BD     		pop	{r1, r2, r4, r5, r6, pc}
 739              	.L34:
 740              		.align	2
 741              	.L33:
 742 0088 6C070000 		.word	1900
 743 008c 35000000 		.word	.LC30
 744 0090 37000000 		.word	.LC32
 745 0094 39000000 		.word	.LC34
 746              		.cfi_endproc
 747              	.LFE37:
 749              		.section	.text.append_v9_command,"ax",%progbits
 750              		.align	1
 751              		.global	append_v9_command
 752              		.code	16
 753              		.thumb_func
 755              	append_v9_command:
 756              	.LFB38:
  89:../scr/command.c **** int append_v9_command(char *buff, char* command) {
 757              		.loc 1 89 0
 758              		.cfi_startproc
 759 0000 38B5     		push	{r3, r4, r5, lr}
 760              	.LCFI8:
 761              		.cfi_def_cfa_offset 16
 762              		.cfi_offset 3, -16
 763              		.cfi_offset 4, -12
 764              		.cfi_offset 5, -8
 765              		.cfi_offset 14, -4
 766              	.LVL60:
  89:../scr/command.c **** int append_v9_command(char *buff, char* command) {
 767              		.loc 1 89 0
 768 0002 0D1C     		mov	r5, r1
 769 0004 041C     		mov	r4, r0
  90:../scr/command.c **** 	strcat(buff, ",V9,");
 770              		.loc 1 90 0
 771 0006 0449     		ldr	r1, .L36
 772              	.LVL61:
 773 0008 FFF7FEFF 		bl	strcat
 774              	.LVL62:
  91:../scr/command.c **** 	strcat(buff, command);
 775              		.loc 1 91 0
 776 000c 291C     		mov	r1, r5
 777 000e 201C     		mov	r0, r4
 778 0010 FFF7FEFF 		bl	strcat
 779              		@ sp needed for prologue
  93:../scr/command.c **** }
 780              		.loc 1 93 0
 781 0014 0120     		mov	r0, #1
 782              	.LVL63:
 783              	.LVL64:
 784 0016 38BD     		pop	{r3, r4, r5, pc}
 785              	.L37:
 786              		.align	2
 787              	.L36:
 788 0018 3B000000 		.word	.LC36
 789              		.cfi_endproc
 790              	.LFE38:
 792              		.section	.text.next_char,"ax",%progbits
 793              		.align	1
 794              		.global	next_char
 795              		.code	16
 796              		.thumb_func
 798              	next_char:
 799              	.LFB39:
  95:../scr/command.c **** int next_char(char* data, char sep, int max) {
 800              		.loc 1 95 0
 801              		.cfi_startproc
 802 0000 38B5     		push	{r3, r4, r5, lr}
 803              	.LCFI9:
 804              		.cfi_def_cfa_offset 16
 805              		.cfi_offset 3, -16
 806              		.cfi_offset 4, -12
 807              		.cfi_offset 5, -8
 808              		.cfi_offset 14, -4
 809              	.LVL65:
  95:../scr/command.c **** int next_char(char* data, char sep, int max) {
 810              		.loc 1 95 0
 811 0002 041C     		mov	r4, r0
 812 0004 151C     		mov	r5, r2
  96:../scr/command.c **** 	char *ptr = strchr(data, sep);
 813              		.loc 1 96 0
 814 0006 FFF7FEFF 		bl	strchr
 815              	.LVL66:
  97:../scr/command.c **** 	if (ptr) {
 816              		.loc 1 97 0
 817 000a 0028     		cmp	r0, #0
 818 000c 03D0     		beq	.L39
  98:../scr/command.c **** 		return (ptr - data) >= max ? max : (ptr - data);
 819              		.loc 1 98 0
 820 000e 001B     		sub	r0, r0, r4
 821              	.LVL67:
 822 0010 A842     		cmp	r0, r5
 823 0012 00DD     		ble	.L39
 824 0014 281C     		mov	r0, r5
 825              	.L39:
 826              		@ sp needed for prologue
 827              	.LVL68:
 828              	.LVL69:
 102:../scr/command.c **** }
 829              		.loc 1 102 0
 830 0016 38BD     		pop	{r3, r4, r5, pc}
 831              		.cfi_endproc
 832              	.LFE39:
 834              		.section	.text.create_v3,"ax",%progbits
 835              		.align	1
 836              		.global	create_v3
 837              		.code	16
 838              		.thumb_func
 840              	create_v3:
 841              	.LFB40:
 105:../scr/command.c **** void create_v3(int blockno) {
 842              		.loc 1 105 0
 843              		.cfi_startproc
 844 0000 38B5     		push	{r3, r4, r5, lr}
 845              	.LCFI10:
 846              		.cfi_def_cfa_offset 16
 847              		.cfi_offset 3, -16
 848              		.cfi_offset 4, -12
 849              		.cfi_offset 5, -8
 850              		.cfi_offset 14, -4
 851              	.LVL70:
 106:../scr/command.c **** 	append_sign(Response);
 852              		.loc 1 106 0
 853 0002 0F4D     		ldr	r5, .L49
 105:../scr/command.c **** void create_v3(int blockno) {
 854              		.loc 1 105 0
 855 0004 041C     		mov	r4, r0
 106:../scr/command.c **** 	append_sign(Response);
 856              		.loc 1 106 0
 857 0006 281C     		mov	r0, r5
 858              	.LVL71:
 859 0008 FFF7FEFF 		bl	append_sign
 107:../scr/command.c **** 	strcat(Response, ",V3,");
 860              		.loc 1 107 0
 861 000c 281C     		mov	r0, r5
 862 000e 0D49     		ldr	r1, .L49+4
 863 0010 FFF7FEFF 		bl	strcat
 108:../scr/command.c **** 	if (blockno >= 10000) {
 864              		.loc 1 108 0
 865 0014 0C4B     		ldr	r3, .L49+8
 866 0016 9C42     		cmp	r4, r3
 867 0018 02DD     		ble	.L43
 109:../scr/command.c **** 		append_int(Response, 5, blockno);
 868              		.loc 1 109 0
 869 001a 281C     		mov	r0, r5
 870 001c 0521     		mov	r1, #5
 871 001e 0BE0     		b	.L48
 872              	.L43:
 110:../scr/command.c **** 	} else if (blockno >= 1000) {
 873              		.loc 1 110 0
 874 0020 0A4A     		ldr	r2, .L49+12
 111:../scr/command.c **** 		append_int(Response, 4, blockno);
 875              		.loc 1 111 0
 876 0022 281C     		mov	r0, r5
 877 0024 0421     		mov	r1, #4
 110:../scr/command.c **** 	} else if (blockno >= 1000) {
 878              		.loc 1 110 0
 879 0026 9442     		cmp	r4, r2
 880 0028 06DC     		bgt	.L48
 113:../scr/command.c **** 		append_int(Response, 3, blockno);
 881              		.loc 1 113 0
 882 002a 0321     		mov	r1, #3
 112:../scr/command.c **** 	} else if (blockno >= 100) {
 883              		.loc 1 112 0
 884 002c 632C     		cmp	r4, #99
 885 002e 03DC     		bgt	.L48
 115:../scr/command.c **** 		append_int(Response, 2, blockno);
 886              		.loc 1 115 0
 887 0030 0221     		mov	r1, #2
 114:../scr/command.c **** 	} else if (blockno >= 10) {
 888              		.loc 1 114 0
 889 0032 092C     		cmp	r4, #9
 890 0034 00DC     		bgt	.L48
 117:../scr/command.c **** 		append_int(Response, 1, blockno);
 891              		.loc 1 117 0
 892 0036 0121     		mov	r1, #1
 893              	.L48:
 894 0038 221C     		mov	r2, r4
 895 003a FFF7FEFF 		bl	append_int
 896              		@ sp needed for prologue
 897              	.LVL72:
 119:../scr/command.c **** }
 898              		.loc 1 119 0
 899 003e 38BD     		pop	{r3, r4, r5, pc}
 900              	.L50:
 901              		.align	2
 902              	.L49:
 903 0040 00000000 		.word	.LANCHOR1
 904 0044 40000000 		.word	.LC39
 905 0048 0F270000 		.word	9999
 906 004c E7030000 		.word	999
 907              		.cfi_endproc
 908              	.LFE40:
 910              		.global	__aeabi_idivmod
 911              		.section	.text.server_on_command,"ax",%progbits
 912              		.align	1
 913              		.global	server_on_command
 914              		.code	16
 915              		.thumb_func
 917              	server_on_command:
 918              	.LFB43:
 203:../scr/command.c **** 
 204:../scr/command.c **** #if 0
 205:../scr/command.c **** static int sks_cmd_G9(int from, char* command, int argc, char** argv, int size,
 206:../scr/command.c **** 		int total) {
 207:../scr/command.c **** 	//G9, debug setting
 208:../scr/command.c **** 	//*XX,YYYYYYYYYY,G9,HHMMSS,S#
 209:../scr/command.c **** 	char set = 0;
 210:../scr/command.c **** 	if (argv[4] == NULL)
 211:../scr/command.c **** 	return size;
 212:../scr/command.c **** 	set = atoi(argv[4]);
 213:../scr/command.c **** 
 214:../scr/command.c **** 	if(set == 0 || set == 1) {
 215:../scr/command.c **** 		turn_debug(set);
 216:../scr/command.c **** 	} else if(set == 9) { //restart device
 217:../scr/command.c **** 		restart_device();
 218:../scr/command.c **** 	}
 219:../scr/command.c **** 
 220:../scr/command.c **** 	append_sign(Response);
 221:../scr/command.c **** 	append_v9_command(Response, command);
 222:../scr/command.c **** 	strcat(Response, ",");
 223:../scr/command.c **** 	append_int(Response, 1, set);
 224:../scr/command.c **** 	strcat(Response, "#");
 225:../scr/command.c **** 
 226:../scr/command.c **** 	raise_command_coming();
 227:../scr/command.c **** 
 228:../scr/command.c **** 	response = 1;
 229:../scr/command.c **** 	return size;
 230:../scr/command.c **** }
 231:../scr/command.c **** #endif
 232:../scr/command.c **** 
 233:../scr/command.c **** SKS_HANDLER handlers[] = { { "WT", sks_cmd_write_tag }, //get config
 234:../scr/command.c **** 		{ "V9", sks_cmd_v9 }, //get config
 235:../scr/command.c **** 		{ NULL, NULL } };
 236:../scr/command.c **** int server_on_command(int from, char * data, int size) {
 919              		.loc 1 236 0
 920              		.cfi_startproc
 921 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 922              	.LCFI11:
 923              		.cfi_def_cfa_offset 20
 924              		.cfi_offset 4, -20
 925              		.cfi_offset 5, -16
 926              		.cfi_offset 6, -12
 927              		.cfi_offset 7, -8
 928              		.cfi_offset 14, -4
 929              	.LVL73:
 930 0002 A5B0     		sub	sp, sp, #148
 931              	.LCFI12:
 932              		.cfi_def_cfa_offset 168
 933              	.LVL74:
 934              		.loc 1 236 0
 935 0004 0690     		str	r0, [sp, #24]
 936 0006 0591     		str	r1, [sp, #20]
 937 0008 0792     		str	r2, [sp, #28]
 237:../scr/command.c **** #define SKS_MAX_CMD_LEN 10
 238:../scr/command.c **** #define SKS_MAX_ARGV 	25
 239:../scr/command.c **** 	int result = 0;
 240:../scr/command.c **** 	int field = 0;
 241:../scr/command.c **** 	int ftmp;
 242:../scr/command.c **** 	int j = 0;
 243:../scr/command.c **** 	char *ptr = data;
 244:../scr/command.c **** 	//char invalide_code = 0;
 245:../scr/command.c **** 	char command[SKS_MAX_CMD_LEN + 1] = { 0 };
 938              		.loc 1 245 0
 939 000a 21A8     		add	r0, sp, #132
 940              	.LVL75:
 941 000c 0021     		mov	r1, #0
 942              	.LVL76:
 943 000e 0B22     		mov	r2, #11
 944              	.LVL77:
 945 0010 FFF7FEFF 		bl	memset
 946              	.LVL78:
 246:../scr/command.c **** 	//*XX,YYYYYYYYYY,CMD,VVVVVV,PARA1,PARA2,#
 247:../scr/command.c **** 	//sks_log(LOG_INFO, "Process COMMAND size=%d data=%s\r\n", size, data);
 248:../scr/command.c **** 	int endPos = 0;
 249:../scr/command.c **** 	int i = 0;
 250:../scr/command.c **** 	char item_buff[20] = { 0 };
 251:../scr/command.c **** 	char* arg[SKS_MAX_ARGV];
 252:../scr/command.c **** 	for (i = 0; i < size; i++) {
 947              		.loc 1 252 0
 948 0014 0026     		mov	r6, #0
 949 0016 13E0     		b	.L52
 950              	.LVL79:
 951              	.L57:
 253:../scr/command.c **** 		if ((data[i] == '#') || (data[i] == '\n') || (data[i] == '\0')) {
 952              		.loc 1 253 0
 953 0018 059A     		ldr	r2, [sp, #20]
 954 001a 935D     		ldrb	r3, [r2, r6]
 955 001c 0A2B     		cmp	r3, #10
 956 001e 03D0     		beq	.L53
 957 0020 232B     		cmp	r3, #35
 958 0022 01D0     		beq	.L53
 959              		.loc 1 253 0 is_stmt 0 discriminator 1
 960 0024 002B     		cmp	r3, #0
 961 0026 0AD1     		bne	.L54
 962              	.L53:
 254:../scr/command.c **** 			endPos = i + 1;
 963              		.loc 1 254 0 is_stmt 1
 964 0028 0136     		add	r6, r6, #1
 965              	.LVL80:
 255:../scr/command.c **** 			break;
 256:../scr/command.c **** 		}
 257:../scr/command.c **** 	}
 258:../scr/command.c **** 	if (endPos == 0)
 966              		.loc 1 258 0
 967 002a 002E     		cmp	r6, #0
 968 002c 00D1     		bne	.LCB780
 969 002e 8DE0     		b	.L55	@long jump
 970              	.LCB780:
 971 0030 059B     		ldr	r3, [sp, #20]
 972 0032 0024     		mov	r4, #0
 973 0034 0493     		str	r3, [sp, #16]
 974 0036 1F1C     		mov	r7, r3
 975 0038 0394     		str	r4, [sp, #12]
 976 003a 251C     		mov	r5, r4
 977 003c 43E0     		b	.L56
 978              	.LVL81:
 979              	.L54:
 252:../scr/command.c **** 	for (i = 0; i < size; i++) {
 980              		.loc 1 252 0
 981 003e 0136     		add	r6, r6, #1
 982              	.LVL82:
 983              	.L52:
 252:../scr/command.c **** 	for (i = 0; i < size; i++) {
 984              		.loc 1 252 0 is_stmt 0 discriminator 1
 985 0040 0798     		ldr	r0, [sp, #28]
 986 0042 8642     		cmp	r6, r0
 987 0044 E8DB     		blt	.L57
 259:../scr/command.c **** 		return 0; //Waiting for end command sign
 988              		.loc 1 259 0 is_stmt 1
 989 0046 0026     		mov	r6, #0
 990              	.LVL83:
 991 0048 80E0     		b	.L55
 992              	.LVL84:
 993              	.L66:
 994              	.LBB8:
 260:../scr/command.c **** 	//xprintf("endPos: %d \n\r",endPos);
 261:../scr/command.c **** 	for (int i = 0; i < endPos; i++) {
 262:../scr/command.c **** 
 263:../scr/command.c **** 		if ((data[i] == ',') || (data[i] == '\n') || (data[i] == '#')
 995              		.loc 1 263 0
 996 004a 059A     		ldr	r2, [sp, #20]
 997 004c 0499     		ldr	r1, [sp, #16]
 998 004e 135D     		ldrb	r3, [r2, r4]
 999 0050 0131     		add	r1, r1, #1
 1000 0052 0491     		str	r1, [sp, #16]
 1001 0054 0A2B     		cmp	r3, #10
 1002 0056 05D0     		beq	.L58
 1003 0058 2C2B     		cmp	r3, #44
 1004 005a 03D0     		beq	.L58
 1005              		.loc 1 263 0 is_stmt 0 discriminator 1
 1006 005c 232B     		cmp	r3, #35
 1007 005e 01D0     		beq	.L58
 264:../scr/command.c **** 				|| (data[i] == 0x00)) //complete one item
 1008              		.loc 1 264 0 is_stmt 1
 1009 0060 002B     		cmp	r3, #0
 1010 0062 2CD1     		bne	.L59
 1011              	.L58:
 265:../scr/command.c **** 				{
 266:../scr/command.c **** 
 267:../scr/command.c **** 			//xprintf("field xx :%d,%d,%d\n\r",field,i, endPos);
 268:../scr/command.c **** 			if (j > 0) {
 1012              		.loc 1 268 0
 1013 0064 039B     		ldr	r3, [sp, #12]
 1014 0066 002B     		cmp	r3, #0
 1015 0068 1BD0     		beq	.L60
 1016              	.LVL85:
 269:../scr/command.c **** 				//if (memcmp(ptr, "*SS", 3)==0)
 270:../scr/command.c **** 
 271:../scr/command.c **** 				//xprintf("field 1:%d,%d,%d\n\r",field,i, ptr);
 272:../scr/command.c **** 
 273:../scr/command.c **** 				//if (*(uint32_t*) (ptr) == 0x2C53532A) { //*SS,
 274:../scr/command.c **** 				//	xprintf("field = 0");
 275:../scr/command.c **** 				//	field = 0;
 276:../scr/command.c **** 				//}
 277:../scr/command.c **** 
 278:../scr/command.c **** 				//xprintf("field 2:%d,%d,%d\n\r",field,i, ptr);
 279:../scr/command.c **** 
 280:../scr/command.c **** 				ftmp = field;
 281:../scr/command.c **** 				//sks_log(LOG_INFO, "FIELD %d DATA %s", field, item_buff);
 282:../scr/command.c **** 				arg[field % SKS_MAX_ARGV] = ptr;
 1017              		.loc 1 282 0
 1018 006a 281C     		mov	r0, r5
 1019 006c 1921     		mov	r1, #25
 1020 006e FFF7FEFF 		bl	__aeabi_idivmod
 1021 0072 8800     		lsl	r0, r1, #2
 1022 0074 08A9     		add	r1, sp, #32
 1023 0076 4750     		str	r7, [r0, r1]
 283:../scr/command.c **** 				switch (ftmp) {
 1024              		.loc 1 283 0
 1025 0078 002D     		cmp	r5, #0
 1026 007a 02D0     		beq	.L61
 1027 007c 022D     		cmp	r5, #2
 1028 007e 10D1     		bne	.L60
 1029 0080 05E0     		b	.L77
 1030              	.L61:
 284:../scr/command.c **** 				case 0:
 285:../scr/command.c **** 					if (*(uint32_t*) (ptr) != 0x2C53532A) {
 1031              		.loc 1 285 0
 1032 0082 3D68     		ldr	r5, [r7]
 1033              	.LVL86:
 1034 0084 334F     		ldr	r7, .L79
 1035              	.LVL87:
 1036 0086 BD42     		cmp	r5, r7
 1037 0088 5ED1     		bne	.L72
 1038 008a 0125     		mov	r5, #1
 1039 008c 0CE0     		b	.L75
 1040              	.LVL88:
 1041              	.L77:
 286:../scr/command.c **** 
 287:../scr/command.c **** 						return -1; //*SS,
 288:../scr/command.c **** 					}
 289:../scr/command.c **** 					//if (memcmp(ptr, "*SS", 3)) return -1; //Invalid SIGN
 290:../scr/command.c **** 					//field = 0;
 291:../scr/command.c **** 					break;
 292:../scr/command.c **** 				case 1:
 293:../scr/command.c **** 					//sks_log(LOG_INFO, "INVALID DEVID", item_buff);
 294:../scr/command.c **** 					//if (memcmp(ptr, g_config.DEVICE_ID, 10)) invalide_code |= 0x1; //Invalid DevID
 295:../scr/command.c **** 					break;
 296:../scr/command.c **** 				case 2:
 297:../scr/command.c **** 					memcpy(command, ptr,
 298:../scr/command.c **** 							j < SKS_MAX_CMD_LEN ? j : SKS_MAX_CMD_LEN);
 1042              		.loc 1 298 0
 1043 008e 039A     		ldr	r2, [sp, #12]
 1044 0090 0A2A     		cmp	r2, #10
 1045 0092 00DD     		ble	.L63
 1046 0094 0A22     		mov	r2, #10
 1047              	.L63:
 297:../scr/command.c **** 					memcpy(command, ptr,
 1048              		.loc 1 297 0
 1049 0096 21A8     		add	r0, sp, #132
 1050              	.LVL89:
 1051 0098 391C     		mov	r1, r7
 1052 009a FFF7FEFF 		bl	memcpy
 1053 009e 0325     		mov	r5, #3
 1054              	.LVL90:
 299:../scr/command.c **** 					break;
 1055              		.loc 1 299 0
 1056 00a0 02E0     		b	.L75
 1057              	.LVL91:
 1058              	.L60:
 300:../scr/command.c **** 				case 3:
 301:../scr/command.c **** 					//if (memcmp(ptr, g_config.ADMINCODE, 6)) invalide_code |= 0x2; //Invalid AdminCode
 302:../scr/command.c **** 					break;
 303:../scr/command.c **** 				default:
 304:../scr/command.c **** 					//return endPos;
 305:../scr/command.c **** 					break;
 306:../scr/command.c **** 				}
 307:../scr/command.c **** 			}
 308:../scr/command.c **** 			//else
 309:../scr/command.c **** 			//	arg[field%SKS_MAX_ARGV] = NULL;
 310:../scr/command.c **** 			field++;
 1059              		.loc 1 310 0
 1060 00a2 0135     		add	r5, r5, #1
 1061              	.LVL92:
 311:../scr/command.c **** 			if (field >= SKS_MAX_ARGV)
 1062              		.loc 1 311 0
 1063 00a4 182D     		cmp	r5, #24
 1064 00a6 10DC     		bgt	.L64
 1065              	.LVL93:
 1066              	.L75:
 312:../scr/command.c **** 				break;
 313:../scr/command.c **** 			j = 0; //reset index
 314:../scr/command.c **** 			ptr = data + i + 1;
 315:../scr/command.c **** 			arg[field % SKS_MAX_ARGV] = ptr;
 1067              		.loc 1 315 0
 1068 00a8 281C     		mov	r0, r5
 1069 00aa 1921     		mov	r1, #25
 1070 00ac FFF7FEFF 		bl	__aeabi_idivmod
 1071 00b0 049F     		ldr	r7, [sp, #16]
 1072 00b2 8800     		lsl	r0, r1, #2
 1073 00b4 08AB     		add	r3, sp, #32
 313:../scr/command.c **** 			j = 0; //reset index
 1074              		.loc 1 313 0
 1075 00b6 0022     		mov	r2, #0
 1076              		.loc 1 315 0
 1077 00b8 C750     		str	r7, [r0, r3]
 313:../scr/command.c **** 			j = 0; //reset index
 1078              		.loc 1 313 0
 1079 00ba 0392     		str	r2, [sp, #12]
 1080              		.loc 1 315 0
 1081 00bc 02E0     		b	.L65
 1082              	.LVL94:
 1083              	.L59:
 316:../scr/command.c **** 		} else {
 317:../scr/command.c **** 			item_buff[j % sizeof(item_buff)] = data[i];
 318:../scr/command.c **** 			j++;
 1084              		.loc 1 318 0
 1085 00be 0399     		ldr	r1, [sp, #12]
 1086 00c0 0131     		add	r1, r1, #1
 1087 00c2 0391     		str	r1, [sp, #12]
 1088              	.LVL95:
 1089              	.L65:
 261:../scr/command.c **** 	for (int i = 0; i < endPos; i++) {
 1090              		.loc 1 261 0
 1091 00c4 0134     		add	r4, r4, #1
 1092              	.LVL96:
 1093              	.L56:
 261:../scr/command.c **** 	for (int i = 0; i < endPos; i++) {
 1094              		.loc 1 261 0 is_stmt 0 discriminator 1
 1095 00c6 B442     		cmp	r4, r6
 1096 00c8 BFDB     		blt	.L66
 1097              	.L64:
 1098              	.LBE8:
 319:../scr/command.c **** 			item_buff[j] = 0x00;
 320:../scr/command.c **** 		}
 321:../scr/command.c **** 	}
 322:../scr/command.c **** 
 323:../scr/command.c **** 	if (field > SKS_MAX_ARGV)
 1099              		.loc 1 323 0 is_stmt 1
 1100 00ca 192D     		cmp	r5, #25
 1101 00cc 3EDC     		bgt	.L55
 324:../scr/command.c **** 		return endPos; //Too many param
 325:../scr/command.c **** 	if (field <= 3)
 1102              		.loc 1 325 0
 1103 00ce 032D     		cmp	r5, #3
 1104 00d0 3CDD     		ble	.L55
 1105              	.LVL97:
 326:../scr/command.c **** 		return endPos; //Too few param
 327:../scr/command.c **** 
 328:../scr/command.c **** 	i = 0;
 329:../scr/command.c **** 	result = -1;
 330:../scr/command.c **** 	response = 0;
 1106              		.loc 1 330 0
 1107 00d2 214C     		ldr	r4, .L79+4
 1108              	.LVL98:
 1109 00d4 0027     		mov	r7, #0
 1110              	.LVL99:
 1111 00d6 2760     		str	r7, [r4]
 1112 00d8 204C     		ldr	r4, .L79+8
 331:../scr/command.c **** 	while (handlers[i].cmd) {
 1113              		.loc 1 331 0
 1114 00da 21E0     		b	.L67
 1115              	.LVL100:
 1116              	.L71:
 332:../scr/command.c **** 		if (strcmp(command, handlers[i].cmd) == 0) {
 1117              		.loc 1 332 0
 1118 00dc 21A8     		add	r0, sp, #132
 1119 00de FFF7FEFF 		bl	strcmp
 1120 00e2 0C34     		add	r4, r4, #12
 1121 00e4 0028     		cmp	r0, #0
 1122 00e6 1AD1     		bne	.L68
 333:../scr/command.c **** #if 0
 334:../scr/command.c **** 			if (invalide_code)
 335:../scr/command.c **** 			{
 336:../scr/command.c **** 				//sks_log(LOG_INFO, "COMMAND  invalide_code %s handlers[%d].cmd=%s", command, i, handlers[i].cm
 337:../scr/command.c **** 				//Allow All command from SKS_CMD_SOURCE_SERIAL
 338:../scr/command.c **** 				if (from == SKS_CMD_SOURCE_SERIAL)
 339:../scr/command.c **** 				{
 340:../scr/command.c **** 
 341:../scr/command.c **** 				}
 342:../scr/command.c **** 				else if(!(handlers[i].dis_pass & from)) return endPos; //Invalid Code
 343:../scr/command.c **** 			}
 344:../scr/command.c **** #endif
 345:../scr/command.c **** 			//sks_log(LOG_INFO, "COMMAND A %s handlers[%d].cmd=%s", command, i, handlers[i].cmd);
 346:../scr/command.c **** 			if (!(handlers[i].dis_mask & from)) //Chi cho phep gui lenh tu nguon
 1123              		.loc 1 346 0
 1124 00e8 0C20     		mov	r0, #12
 1125 00ea 4743     		mul	r7, r0
 1126              	.LVL101:
 1127 00ec 1B4A     		ldr	r2, .L79+8
 1128 00ee D419     		add	r4, r2, r7
 1129 00f0 2189     		ldrh	r1, [r4, #8]
 1130 00f2 069F     		ldr	r7, [sp, #24]
 1131 00f4 3940     		and	r1, r7
 1132 00f6 29D1     		bne	.L55
 347:../scr/command.c **** 			{
 348:../scr/command.c **** 				write_flash = 0;
 1133              		.loc 1 348 0
 1134 00f8 194F     		ldr	r7, .L79+12
 349:../scr/command.c **** 				//result = handlers[i].handler(from, command, field, arg, endPos-(arg[4]-data), size-(arg[4]-da
 350:../scr/command.c **** 				memset(Response, 0, 200);
 1135              		.loc 1 350 0
 1136 00fa C822     		mov	r2, #200
 348:../scr/command.c **** 				write_flash = 0;
 1137              		.loc 1 348 0
 1138 00fc 3960     		str	r1, [r7]
 1139              		.loc 1 350 0
 1140 00fe 194F     		ldr	r7, .L79+16
 1141 0100 381C     		mov	r0, r7
 1142 0102 FFF7FEFF 		bl	memset
 351:../scr/command.c **** 				result = handlers[i].handler(from, command, field, arg, endPos,
 1143              		.loc 1 351 0
 1144 0106 079B     		ldr	r3, [sp, #28]
 1145 0108 0096     		str	r6, [sp]
 1146 010a 0193     		str	r3, [sp, #4]
 1147 010c 6468     		ldr	r4, [r4, #4]
 1148 010e 0698     		ldr	r0, [sp, #24]
 1149 0110 21A9     		add	r1, sp, #132
 1150 0112 2A1C     		mov	r2, r5
 1151 0114 08AB     		add	r3, sp, #32
 1152 0116 A047     		blx	r4
 1153              	.LVL102:
 352:../scr/command.c **** 						size);
 353:../scr/command.c **** 				//sks_log(LOG_INFO, "***********===************COMMAND B%s handlers[%d].cmd=%s, total %d result
 354:../scr/command.c **** 				//if (write_flash)
 355:../scr/command.c **** 				//	flash_write_config_info(&g_config);
 356:../scr/command.c **** 			}
 357:../scr/command.c **** 			break;
 358:../scr/command.c **** 		}
 359:../scr/command.c **** 		i++;
 360:../scr/command.c **** 	}
 361:../scr/command.c **** 
 362:../scr/command.c **** 	if (result > 0) {
 1154              		.loc 1 362 0
 1155 0118 0028     		cmp	r0, #0
 1156 011a 05DC     		bgt	.L69
 1157 011c 10E0     		b	.L78
 1158              	.LVL103:
 1159              	.L68:
 359:../scr/command.c **** 		i++;
 1160              		.loc 1 359 0
 1161 011e 0137     		add	r7, r7, #1
 1162              	.LVL104:
 1163              	.L67:
 331:../scr/command.c **** 	while (handlers[i].cmd) {
 1164              		.loc 1 331 0 discriminator 1
 1165 0120 2168     		ldr	r1, [r4]
 1166 0122 0029     		cmp	r1, #0
 1167 0124 DAD1     		bne	.L71
 1168 0126 11E0     		b	.L55
 1169              	.LVL105:
 1170              	.L69:
 363:../scr/command.c **** 		//if (!((result==0)&&(arg[4][0]=='#'))) return 0; //WAITING FOR MORE DATA
 364:../scr/command.c **** 		//Make V9 OK Report
 365:../scr/command.c **** 		if (response) {
 1171              		.loc 1 365 0
 1172 0128 0B4E     		ldr	r6, .L79+4
 1173              	.LVL106:
 1174 012a 3568     		ldr	r5, [r6]
 1175              	.LVL107:
 1176 012c 061C     		mov	r6, r0
 1177 012e 002D     		cmp	r5, #0
 1178 0130 0CD0     		beq	.L55
 366:../scr/command.c **** 			//msg.ulUpdate = ulSecCount;
 367:../scr/command.c **** 
 368:../scr/command.c **** 			if (from == SKS_CMD_SOURCE_COM1) {
 1179              		.loc 1 368 0
 1180 0132 0699     		ldr	r1, [sp, #24]
 1181 0134 0129     		cmp	r1, #1
 1182 0136 09D1     		bne	.L55
 369:../scr/command.c **** 				xprintf(Response);
 1183              		.loc 1 369 0
 1184 0138 381C     		mov	r0, r7
 1185              	.LVL108:
 1186 013a FFF7FEFF 		bl	xprintf
 1187 013e 05E0     		b	.L55
 1188              	.LVL109:
 1189              	.L78:
 370:../scr/command.c **** 			} else if (from == SKS_CMD_SOURCE_COM2) {
 371:../scr/command.c **** 				//ExtSerial_PutString(Response);
 372:../scr/command.c **** 			} else {
 373:../scr/command.c **** 			}
 374:../scr/command.c **** 			//msg.
 375:../scr/command.c **** 			//sks_log(LOG_INFO, "RESPONSE:%s", Response);
 376:../scr/command.c **** 		}
 377:../scr/command.c **** 		//REQUEST:*SS,YYYYYYYYYY,U2,112233,packid,size#DATA#
 378:../scr/command.c **** 		//SIZE=packid,size#
 379:../scr/command.c **** 		//TOTALSIZE=packid,size#DATA# =>TOTAL_SIZE>=size+rcv_size+1
 380:../scr/command.c **** 		//result += (arg[4]-data);
 381:../scr/command.c **** 		//sks_log(LOG_INFO, "SOCKET USE, REMOVE: %d BYTES", result);
 382:../scr/command.c **** 	} else if (result < 0) {
 1190              		.loc 1 382 0
 1191 0140 0028     		cmp	r0, #0
 1192 0142 03D1     		bne	.L55
 1193 0144 061C     		mov	r6, r0
 1194              	.LVL110:
 1195 0146 01E0     		b	.L55
 1196              	.LVL111:
 1197              	.L72:
 1198              	.LBB9:
 287:../scr/command.c **** 						return -1; //*SS,
 1199              		.loc 1 287 0
 1200 0148 0122     		mov	r2, #1
 1201 014a 5642     		neg	r6, r2
 1202              	.LVL112:
 1203              	.L55:
 1204              	.LBE9:
 383:../scr/command.c **** 		result = endPos;
 384:../scr/command.c **** 		//sks_log(LOG_INFO, "REMOVE1: %d BYTES", result);
 385:../scr/command.c **** 	}
 386:../scr/command.c **** 	return result;
 387:../scr/command.c **** }
 1205              		.loc 1 387 0
 1206 014c 301C     		mov	r0, r6
 1207 014e 25B0     		add	sp, sp, #148
 1208              		@ sp needed for prologue
 1209 0150 F0BD     		pop	{r4, r5, r6, r7, pc}
 1210              	.L80:
 1211 0152 C046     		.align	2
 1212              	.L79:
 1213 0154 2A53532C 		.word	743658282
 1214 0158 00000000 		.word	.LANCHOR0
 1215 015c 00000000 		.word	.LANCHOR3
 1216 0160 00000000 		.word	.LANCHOR4
 1217 0164 00000000 		.word	.LANCHOR1
 1218              		.cfi_endproc
 1219              	.LFE43:
 1221              		.global	handlers
 1222              		.global	write_flash
 1223              		.global	HexChar
 1224              		.section	.bss.Response,"aw",%nobits
 1225              		.set	.LANCHOR1,. + 0
 1228              	Response:
 1229 0000 00000000 		.space	256
 1229      00000000 
 1229      00000000 
 1229      00000000 
 1229      00000000 
 1230              		.section	.rodata.str1.1,"aMS",%progbits,1
 1231              	.LC3:
 1232 0000 6A6D7020 		.ascii	"jmp set\015\012\000"
 1232      7365740D 
 1232      0A00
 1233              	.LC7:
 1234 000a 2C00     		.ascii	",\000"
 1235              	.LC9:
 1236 000c 64726976 		.ascii	"driverID: %s, %d\015\012\000"
 1236      65724944 
 1236      3A202573 
 1236      2C202564 
 1236      0D0A00
 1237              	.LC11:
 1238 001f 74616720 		.ascii	"tag data: %s\000"
 1238      64617461 
 1238      3A202573 
 1238      00
 1239              	.LC14:
 1240 002c 230D0A00 		.ascii	"#\015\012\000"
 1241              	.LC28:
 1242 0030 2A53532C 		.ascii	"*SS,\000"
 1242      00
 1243              	.LC30:
 1244 0035 2D00     		.ascii	"-\000"
 1245              	.LC32:
 1246 0037 2000     		.ascii	" \000"
 1247              	.LC34:
 1248 0039 3A00     		.ascii	":\000"
 1249              	.LC36:
 1250 003b 2C56392C 		.ascii	",V9,\000"
 1250      00
 1251              	.LC39:
 1252 0040 2C56332C 		.ascii	",V3,\000"
 1252      00
 1253              	.LC47:
 1254 0045 575400   		.ascii	"WT\000"
 1255              	.LC48:
 1256 0048 563900   		.ascii	"V9\000"
 1257              	.LC49:
 1258 004b 31323334 		.ascii	"1234567890ABCDEF\000"
 1258      35363738 
 1258      39304142 
 1258      43444546 
 1258      00
 1259              		.section	.bss.write_flash,"aw",%nobits
 1260              		.align	2
 1261              		.set	.LANCHOR4,. + 0
 1264              	write_flash:
 1265 0000 00000000 		.space	4
 1266              		.section	.bss.response,"aw",%nobits
 1267              		.align	2
 1268              		.set	.LANCHOR0,. + 0
 1271              	response:
 1272 0000 00000000 		.space	4
 1273              		.section	.data.handlers,"aw",%progbits
 1274              		.align	2
 1275              		.set	.LANCHOR3,. + 0
 1278              	handlers:
 1279 0000 45000000 		.word	.LC47
 1280 0004 00000000 		.word	sks_cmd_write_tag
 1281 0008 00000000 		.space	4
 1282 000c 48000000 		.word	.LC48
 1283 0010 00000000 		.word	sks_cmd_v9
 1284 0014 00000000 		.space	4
 1285 0018 00000000 		.word	0
 1286 001c 00000000 		.word	0
 1287 0020 00000000 		.space	4
 1288              		.section	.data.HexChar,"aw",%progbits
 1289              		.align	2
 1290              		.set	.LANCHOR2,. + 0
 1293              	HexChar:
 1294 0000 4B000000 		.word	.LC49
 1295              		.text
 1296              	.Letext0:
 1297              		.file 2 "c:\\eclipseindigo\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 1298              		.file 3 "c:\\eclipseindigo\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 1299              		.file 4 "c:\\eclipseindigo\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
DEFINED SYMBOLS
                            *ABS*:00000000 command.c
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:18     .text.sks_cmd_v9:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:22     .text.sks_cmd_v9:00000000 sks_cmd_v9
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:53     .text.sks_cmd_v9:00000018 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:58     .text.sks_cmd_write_tag:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:62     .text.sks_cmd_write_tag:00000000 sks_cmd_write_tag
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:357    .text.sks_cmd_write_tag:0000016c $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:372    .text.append_int:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:377    .text.append_int:00000000 append_int
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:449    .text.append_hex:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:454    .text.append_hex:00000000 append_hex
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:502    .text.append_hex:00000028 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:507    .text.append_hex_long:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:512    .text.append_hex_long:00000000 append_hex_long
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:602    .text.append_hex_long:0000005c $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:607    .text.append_sign:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:612    .text.append_sign:00000000 append_sign
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:633    .text.append_sign:0000000c $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:638    .text.append_time:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:643    .text.append_time:00000000 append_time
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:742    .text.append_time:00000088 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:750    .text.append_v9_command:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:755    .text.append_v9_command:00000000 append_v9_command
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:788    .text.append_v9_command:00000018 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:793    .text.next_char:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:798    .text.next_char:00000000 next_char
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:835    .text.create_v3:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:840    .text.create_v3:00000000 create_v3
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:903    .text.create_v3:00000040 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:912    .text.server_on_command:00000000 $t
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:917    .text.server_on_command:00000000 server_on_command
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1213   .text.server_on_command:00000154 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1278   .data.handlers:00000000 handlers
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1264   .bss.write_flash:00000000 write_flash
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1293   .data.HexChar:00000000 HexChar
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1228   .bss.Response:00000000 Response
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1229   .bss.Response:00000000 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1260   .bss.write_flash:00000000 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1267   .bss.response:00000000 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1271   .bss.response:00000000 response
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1274   .data.handlers:00000000 $d
C:\Users\NGUYEN~1\AppData\Local\Temp\cclRqWco.s:1289   .data.HexChar:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
atoi
xprintf
memset
memccpy
strcat
tagData
writeNow
__aeabi_uidivmod
__aeabi_uidiv
strlen
strcpy
gmtime
strchr
__aeabi_idivmod
memcpy
strcmp
