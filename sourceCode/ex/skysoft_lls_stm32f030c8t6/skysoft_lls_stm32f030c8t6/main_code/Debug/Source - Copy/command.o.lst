   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"command.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	__aeabi_uidivmod
  18              		.global	__aeabi_uidiv
  19              		.section	.text.append_int,"ax",%progbits
  20              		.align	1
  21              		.global	append_int
  22              		.code	16
  23              		.thumb_func
  25              	append_int:
  26              	.LFB33:
  27              		.file 1 "../Source - Copy/command.c"
   1:../Source - Copy/command.c **** /*
   2:../Source - Copy/command.c ****  * report.c
   3:../Source - Copy/command.c ****  *
   4:../Source - Copy/command.c ****  *  Created on: Aug 29, 2012
   5:../Source - Copy/command.c ****  *      Author: Admin
   6:../Source - Copy/command.c ****  */
   7:../Source - Copy/command.c **** 
   8:../Source - Copy/command.c **** #include <stdio.h>
   9:../Source - Copy/command.c **** #include <stdlib.h>
  10:../Source - Copy/command.c **** #include <string.h>
  11:../Source - Copy/command.c **** #include <stdarg.h>
  12:../Source - Copy/command.c **** 
  13:../Source - Copy/command.c **** #include "printf-stdarg.h"
  14:../Source - Copy/command.c **** #include "xprintf.h"
  15:../Source - Copy/command.c **** 
  16:../Source - Copy/command.c **** #include <time.h>
  17:../Source - Copy/command.c **** #include "DataUtil.h"
  18:../Source - Copy/command.c **** #include "command.h"
  19:../Source - Copy/command.c **** #include "main.h"
  20:../Source - Copy/command.c **** #include "alarm.h"
  21:../Source - Copy/command.c **** #include "config.h"
  22:../Source - Copy/command.c **** #include "flash.h"
  23:../Source - Copy/command.c **** #include "Util.h"
  24:../Source - Copy/command.c **** 
  25:../Source - Copy/command.c **** extern volatile uint32_t ulSecCount;
  26:../Source - Copy/command.c **** 
  27:../Source - Copy/command.c **** typedef int (*SKS_CMD_HANDLER)(int from, char* command, int argc, char** argv, int size, int total)
  28:../Source - Copy/command.c **** 
  29:../Source - Copy/command.c **** typedef struct _SKS_HANDLER {
  30:../Source - Copy/command.c **** 	char* cmd;
  31:../Source - Copy/command.c **** 	SKS_CMD_HANDLER handler;
  32:../Source - Copy/command.c **** 	unsigned short dis_mask; //Disable handle from source mask
  33:../Source - Copy/command.c **** 	unsigned short dis_pass; //This command can execute without pass
  34:../Source - Copy/command.c **** } SKS_HANDLER;
  35:../Source - Copy/command.c **** 
  36:../Source - Copy/command.c **** char *HexChar = "1234567890ABCDEF";
  37:../Source - Copy/command.c **** static int response = 0;
  38:../Source - Copy/command.c **** 
  39:../Source - Copy/command.c **** //void turn_debug(char mark);
  40:../Source - Copy/command.c **** 
  41:../Source - Copy/command.c **** void append_int(char* str, uint8_t len, uint32_t val) {
  28              		.loc 1 41 0
  29              		.cfi_startproc
  30 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 32
  33              		.cfi_offset 0, -32
  34              		.cfi_offset 1, -28
  35              		.cfi_offset 2, -24
  36              		.cfi_offset 4, -20
  37              		.cfi_offset 5, -16
  38              		.cfi_offset 6, -12
  39              		.cfi_offset 7, -8
  40              		.cfi_offset 14, -4
  41              	.LVL0:
  42              		.loc 1 41 0
  43 0002 041C     		mov	r4, r0
  44 0004 0F1C     		mov	r7, r1
  45 0006 151C     		mov	r5, r2
  42:../Source - Copy/command.c **** 	uint8_t i;
  43:../Source - Copy/command.c **** 	char *ptr = str + strlen(str);
  46              		.loc 1 43 0
  47 0008 FFF7FEFF 		bl	strlen
  48              	.LVL1:
  49 000c 2618     		add	r6, r4, r0
  50              	.LVL2:
  44:../Source - Copy/command.c **** 	for (i = 1; i <= len; i++) {
  51              		.loc 1 44 0
  52 000e 0124     		mov	r4, #1
  53              	.LVL3:
  54 0010 0FE0     		b	.L2
  55              	.LVL4:
  56              	.L3:
  45:../Source - Copy/command.c **** 		ptr[len - i] = (uint8_t) ((val % 10UL) + '0');
  57              		.loc 1 45 0 discriminator 2
  58 0012 381B     		sub	r0, r7, r4
  59 0014 0190     		str	r0, [sp, #4]
  60 0016 0A21     		mov	r1, #10
  61 0018 281C     		mov	r0, r5
  62 001a FFF7FEFF 		bl	__aeabi_uidivmod
  63 001e 019B     		ldr	r3, [sp, #4]
  64 0020 3031     		add	r1, r1, #48
  65 0022 F154     		strb	r1, [r6, r3]
  46:../Source - Copy/command.c **** 		val /= 10;
  66              		.loc 1 46 0 discriminator 2
  67 0024 281C     		mov	r0, r5
  68 0026 0A21     		mov	r1, #10
  69 0028 FFF7FEFF 		bl	__aeabi_uidiv
  44:../Source - Copy/command.c **** 	for (i = 1; i <= len; i++) {
  70              		.loc 1 44 0 discriminator 2
  71 002c 0134     		add	r4, r4, #1
  72              	.LVL5:
  73              		.loc 1 46 0 discriminator 2
  74 002e 051C     		mov	r5, r0
  75              	.LVL6:
  44:../Source - Copy/command.c **** 	for (i = 1; i <= len; i++) {
  76              		.loc 1 44 0 discriminator 2
  77 0030 E4B2     		uxtb	r4, r4
  78              	.LVL7:
  79              	.L2:
  44:../Source - Copy/command.c **** 	for (i = 1; i <= len; i++) {
  80              		.loc 1 44 0 is_stmt 0 discriminator 1
  81 0032 BC42     		cmp	r4, r7
  82 0034 EDD9     		bls	.L3
  47:../Source - Copy/command.c **** 	}
  48:../Source - Copy/command.c **** 	ptr[i - 1] = '\0';
  83              		.loc 1 48 0 is_stmt 1
  84 0036 3219     		add	r2, r6, r4
  85 0038 013A     		sub	r2, r2, #1
  86 003a 0021     		mov	r1, #0
  87 003c 1170     		strb	r1, [r2]
  88              		@ sp needed for prologue
  89              	.LVL8:
  90              	.LVL9:
  91              	.LVL10:
  49:../Source - Copy/command.c **** }
  92              		.loc 1 49 0
  93 003e F7BD     		pop	{r0, r1, r2, r4, r5, r6, r7, pc}
  94              		.cfi_endproc
  95              	.LFE33:
  97              		.section	.text.append_hex,"ax",%progbits
  98              		.align	1
  99              		.global	append_hex
 100              		.code	16
 101              		.thumb_func
 103              	append_hex:
 104              	.LFB34:
  50:../Source - Copy/command.c **** 
  51:../Source - Copy/command.c **** void append_hex(char* str, uint8_t val) {
 105              		.loc 1 51 0
 106              		.cfi_startproc
 107 0000 38B5     		push	{r3, r4, r5, lr}
 108              	.LCFI1:
 109              		.cfi_def_cfa_offset 16
 110              		.cfi_offset 3, -16
 111              		.cfi_offset 4, -12
 112              		.cfi_offset 5, -8
 113              		.cfi_offset 14, -4
 114              	.LVL11:
 115              		.loc 1 51 0
 116 0002 0D1C     		mov	r5, r1
 117 0004 041C     		mov	r4, r0
  52:../Source - Copy/command.c **** 	char *ptr = str + strlen(str);
 118              		.loc 1 52 0
 119 0006 FFF7FEFF 		bl	strlen
 120              	.LVL12:
  53:../Source - Copy/command.c **** 	ptr[0] = HexChar[val >> 4];
 121              		.loc 1 53 0
 122 000a 074B     		ldr	r3, .L5
 123 000c 2A09     		lsr	r2, r5, #4
 124 000e 1968     		ldr	r1, [r3]
  52:../Source - Copy/command.c **** 	char *ptr = str + strlen(str);
 125              		.loc 1 52 0
 126 0010 2418     		add	r4, r4, r0
 127              	.LVL13:
 128              		.loc 1 53 0
 129 0012 885C     		ldrb	r0, [r1, r2]
  54:../Source - Copy/command.c **** 	ptr[1] = HexChar[val & 0xF];
 130              		.loc 1 54 0
 131 0014 0F22     		mov	r2, #15
  53:../Source - Copy/command.c **** 	ptr[0] = HexChar[val >> 4];
 132              		.loc 1 53 0
 133 0016 2070     		strb	r0, [r4]
 134              		.loc 1 54 0
 135 0018 1968     		ldr	r1, [r3]
 136 001a 1540     		and	r5, r2
 137 001c 485D     		ldrb	r0, [r1, r5]
  55:../Source - Copy/command.c **** 	ptr[2] = 0;
 138              		.loc 1 55 0
 139 001e 0023     		mov	r3, #0
  54:../Source - Copy/command.c **** 	ptr[1] = HexChar[val & 0xF];
 140              		.loc 1 54 0
 141 0020 6070     		strb	r0, [r4, #1]
 142              		.loc 1 55 0
 143 0022 A370     		strb	r3, [r4, #2]
 144              		@ sp needed for prologue
 145              	.LVL14:
  56:../Source - Copy/command.c **** }
 146              		.loc 1 56 0
 147 0024 38BD     		pop	{r3, r4, r5, pc}
 148              	.L6:
 149 0026 C046     		.align	2
 150              	.L5:
 151 0028 00000000 		.word	.LANCHOR0
 152              		.cfi_endproc
 153              	.LFE34:
 155              		.section	.text.append_hex_long,"ax",%progbits
 156              		.align	1
 157              		.global	append_hex_long
 158              		.code	16
 159              		.thumb_func
 161              	append_hex_long:
 162              	.LFB35:
  57:../Source - Copy/command.c **** 
  58:../Source - Copy/command.c **** void append_hex_long(char* str, long val) {
 163              		.loc 1 58 0
 164              		.cfi_startproc
 165 0000 38B5     		push	{r3, r4, r5, lr}
 166              	.LCFI2:
 167              		.cfi_def_cfa_offset 16
 168              		.cfi_offset 3, -16
 169              		.cfi_offset 4, -12
 170              		.cfi_offset 5, -8
 171              		.cfi_offset 14, -4
 172              	.LVL15:
 173              		.loc 1 58 0
 174 0002 0D1C     		mov	r5, r1
 175 0004 041C     		mov	r4, r0
  59:../Source - Copy/command.c **** 	char *ptr = str + strlen(str);
 176              		.loc 1 59 0
 177 0006 FFF7FEFF 		bl	strlen
 178              	.LVL16:
  60:../Source - Copy/command.c **** 	ptr[0] = HexChar[val >> 28];
 179              		.loc 1 60 0
 180 000a 144A     		ldr	r2, .L8
  59:../Source - Copy/command.c **** 	char *ptr = str + strlen(str);
 181              		.loc 1 59 0
 182 000c 2418     		add	r4, r4, r0
 183              	.LVL17:
 184              		.loc 1 60 0
 185 000e 1168     		ldr	r1, [r2]
 186 0010 2817     		asr	r0, r5, #28
 187 0012 0B5C     		ldrb	r3, [r1, r0]
  61:../Source - Copy/command.c **** 	ptr[1] = HexChar[(val >> 24) & 0xF];
 188              		.loc 1 61 0
 189 0014 2916     		asr	r1, r5, #24
  60:../Source - Copy/command.c **** 	ptr[0] = HexChar[val >> 28];
 190              		.loc 1 60 0
 191 0016 2370     		strb	r3, [r4]
 192              		.loc 1 61 0
 193 0018 1068     		ldr	r0, [r2]
 194 001a 0F23     		mov	r3, #15
 195 001c 1940     		and	r1, r3
 196 001e 415C     		ldrb	r1, [r0, r1]
 197              		@ sp needed for prologue
 198 0020 6170     		strb	r1, [r4, #1]
  62:../Source - Copy/command.c **** 	ptr[2] = HexChar[(val >> 20) & 0xF];
 199              		.loc 1 62 0
 200 0022 1068     		ldr	r0, [r2]
 201 0024 2915     		asr	r1, r5, #20
 202 0026 1940     		and	r1, r3
 203 0028 415C     		ldrb	r1, [r0, r1]
 204 002a A170     		strb	r1, [r4, #2]
  63:../Source - Copy/command.c **** 	ptr[3] = HexChar[(val >> 16) & 0xF];
 205              		.loc 1 63 0
 206 002c 1068     		ldr	r0, [r2]
 207 002e 2914     		asr	r1, r5, #16
 208 0030 1940     		and	r1, r3
 209 0032 415C     		ldrb	r1, [r0, r1]
  64:../Source - Copy/command.c **** 	ptr[4] = HexChar[(val >> 12) & 0xF];
 210              		.loc 1 64 0
 211 0034 2813     		asr	r0, r5, #12
  63:../Source - Copy/command.c **** 	ptr[3] = HexChar[(val >> 16) & 0xF];
 212              		.loc 1 63 0
 213 0036 E170     		strb	r1, [r4, #3]
 214              		.loc 1 64 0
 215 0038 1268     		ldr	r2, [r2]
 216 003a 1840     		and	r0, r3
 217 003c 115C     		ldrb	r1, [r2, r0]
  65:../Source - Copy/command.c **** 	ptr[5] = HexChar[(val >> 8) & 0xF];
 218              		.loc 1 65 0
 219 003e 2812     		asr	r0, r5, #8
  64:../Source - Copy/command.c **** 	ptr[4] = HexChar[(val >> 12) & 0xF];
 220              		.loc 1 64 0
 221 0040 2171     		strb	r1, [r4, #4]
 222              		.loc 1 65 0
 223 0042 1840     		and	r0, r3
 224 0044 115C     		ldrb	r1, [r2, r0]
  66:../Source - Copy/command.c **** 	ptr[6] = HexChar[(val >> 4) & 0xF];
 225              		.loc 1 66 0
 226 0046 2811     		asr	r0, r5, #4
  65:../Source - Copy/command.c **** 	ptr[5] = HexChar[(val >> 8) & 0xF];
 227              		.loc 1 65 0
 228 0048 6171     		strb	r1, [r4, #5]
 229              		.loc 1 66 0
 230 004a 1840     		and	r0, r3
 231 004c 115C     		ldrb	r1, [r2, r0]
  67:../Source - Copy/command.c **** 	ptr[7] = HexChar[val & 0xF];
 232              		.loc 1 67 0
 233 004e 1D40     		and	r5, r3
 234              	.LVL18:
  66:../Source - Copy/command.c **** 	ptr[6] = HexChar[(val >> 4) & 0xF];
 235              		.loc 1 66 0
 236 0050 A171     		strb	r1, [r4, #6]
 237              		.loc 1 67 0
 238 0052 505D     		ldrb	r0, [r2, r5]
  68:../Source - Copy/command.c **** 	ptr[8] = 0x0;
 239              		.loc 1 68 0
 240 0054 0023     		mov	r3, #0
  67:../Source - Copy/command.c **** 	ptr[7] = HexChar[val & 0xF];
 241              		.loc 1 67 0
 242 0056 E071     		strb	r0, [r4, #7]
 243              		.loc 1 68 0
 244 0058 2372     		strb	r3, [r4, #8]
 245              	.LVL19:
  69:../Source - Copy/command.c **** }
 246              		.loc 1 69 0
 247 005a 38BD     		pop	{r3, r4, r5, pc}
 248              	.L9:
 249              		.align	2
 250              	.L8:
 251 005c 00000000 		.word	.LANCHOR0
 252              		.cfi_endproc
 253              	.LFE35:
 255              		.section	.text.cmd_response,"ax",%progbits
 256              		.align	1
 257              		.global	cmd_response
 258              		.code	16
 259              		.thumb_func
 261              	cmd_response:
 262              	.LFB36:
  70:../Source - Copy/command.c **** 
  71:../Source - Copy/command.c **** int cmd_response(char* buff, int size, char *cmd, const char *fmt, ...)
  72:../Source - Copy/command.c **** {
 263              		.loc 1 72 0
 264              		.cfi_startproc
 265 0000 08B4     		push	{r3}
 266              	.LCFI3:
 267              		.cfi_def_cfa_offset 4
 268 0002 FFB5     		push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
 269              	.LCFI4:
 270              		.cfi_def_cfa_offset 40
 271              		.cfi_offset 0, -40
 272              		.cfi_offset 1, -36
 273              		.cfi_offset 2, -32
 274              		.cfi_offset 3, -28
 275              		.cfi_offset 4, -24
 276              		.cfi_offset 5, -20
 277              		.cfi_offset 6, -16
 278              		.cfi_offset 7, -12
 279              		.cfi_offset 14, -8
 280              	.LVL20:
 281              		.loc 1 72 0
 282 0004 09AC     		add	r4, sp, #36
 283 0006 80CC     		ldmia	r4!, {r7}
  73:../Source - Copy/command.c **** 	int n = 0;
  74:../Source - Copy/command.c ****     va_list ap;
  75:../Source - Copy/command.c ****     n = usnprintf(buff, size, "*SS,%s,V9,%s,", g_config.deviceCode, cmd);
 284              		.loc 1 75 0
 285 0008 0E4B     		ldr	r3, .L11
 286 000a 0092     		str	r2, [sp]
 287 000c 0E4A     		ldr	r2, .L11+4
 288              	.LVL21:
  72:../Source - Copy/command.c **** {
 289              		.loc 1 72 0
 290 000e 0E1C     		mov	r6, r1
 291 0010 051C     		mov	r5, r0
 292              		.loc 1 75 0
 293 0012 FFF7FEFF 		bl	usnprintf
 294              	.LVL22:
  76:../Source - Copy/command.c ****     va_start(ap, fmt);
  77:../Source - Copy/command.c ****     char *bufftmp = buff + (n);
 295              		.loc 1 77 0
 296 0016 2D18     		add	r5, r5, r0
 297              	.LVL23:
  78:../Source - Copy/command.c ****     n = uvsnprintf(bufftmp, size-(n+1), (char *) fmt, ap );
 298              		.loc 1 78 0
 299 0018 C043     		mvn	r0, r0
 300              	.LVL24:
 301 001a 3118     		add	r1, r6, r0
 302 001c 3A1C     		mov	r2, r7
 303 001e 231C     		mov	r3, r4
 304 0020 281C     		mov	r0, r5
 305              	.LVL25:
  76:../Source - Copy/command.c ****     va_start(ap, fmt);
 306              		.loc 1 76 0
 307 0022 0394     		str	r4, [sp, #12]
 308              		.loc 1 78 0
 309 0024 FFF7FEFF 		bl	uvsnprintf
 310              	.LVL26:
  79:../Source - Copy/command.c ****     va_end(ap);
  80:../Source - Copy/command.c ****     bufftmp[n] = '#';
 311              		.loc 1 80 0
 312 0028 2322     		mov	r2, #35
 313 002a 2A54     		strb	r2, [r5, r0]
 314              	.LVL27:
  81:../Source - Copy/command.c ****     n++;
  82:../Source - Copy/command.c ****     bufftmp[n] = '\r';
 315              		.loc 1 82 0
 316 002c 0D21     		mov	r1, #13
 317 002e 2D18     		add	r5, r5, r0
 318              	.LVL28:
  83:../Source - Copy/command.c ****     n++;
  84:../Source - Copy/command.c ****     bufftmp[n] = '\n';
 319              		.loc 1 84 0
 320 0030 0A23     		mov	r3, #10
  85:../Source - Copy/command.c ****     return n+1;
 321              		.loc 1 85 0
 322 0032 0330     		add	r0, r0, #3
 323              	.LVL29:
  82:../Source - Copy/command.c ****     bufftmp[n] = '\r';
 324              		.loc 1 82 0
 325 0034 6970     		strb	r1, [r5, #1]
 326              	.LVL30:
  84:../Source - Copy/command.c ****     bufftmp[n] = '\n';
 327              		.loc 1 84 0
 328 0036 AB70     		strb	r3, [r5, #2]
  86:../Source - Copy/command.c **** }
 329              		.loc 1 86 0
 330 0038 04B0     		add	sp, sp, #16
 331              		@ sp needed for prologue
 332              	.LVL31:
 333 003a F0BC     		pop	{r4, r5, r6, r7}
 334 003c 08BC     		pop	{r3}
 335 003e 01B0     		add	sp, sp, #4
 336 0040 1847     		bx	r3
 337              	.L12:
 338 0042 C046     		.align	2
 339              	.L11:
 340 0044 02000000 		.word	g_config+2
 341 0048 00000000 		.word	.LC2
 342              		.cfi_endproc
 343              	.LFE36:
 345              		.section	.text.sks_cmd_set_debug,"ax",%progbits
 346              		.align	1
 347              		.code	16
 348              		.thumb_func
 350              	sks_cmd_set_debug:
 351              	.LFB42:
  87:../Source - Copy/command.c **** 
  88:../Source - Copy/command.c **** int append_sign(char* buff) {
  89:../Source - Copy/command.c **** 	strcpy(buff, "*SS,");
  90:../Source - Copy/command.c **** 	strcat(buff, (char*)g_config.deviceCode);
  91:../Source - Copy/command.c **** 	return 1;
  92:../Source - Copy/command.c **** }
  93:../Source - Copy/command.c **** 
  94:../Source - Copy/command.c **** int append_time(char* buff, time_t ti) {
  95:../Source - Copy/command.c **** 	time_t now = ti;
  96:../Source - Copy/command.c **** 	struct tm *tm = gmtime(&now);
  97:../Source - Copy/command.c **** 	char *ptr = buff + strlen(buff);
  98:../Source - Copy/command.c **** 	append_int(ptr, 4, tm->tm_year + 1900);
  99:../Source - Copy/command.c **** 	strcat(ptr, "-");
 100:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_mon + 1);
 101:../Source - Copy/command.c **** 	strcat(ptr, "-");
 102:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_mday);
 103:../Source - Copy/command.c **** 	strcat(ptr, " ");
 104:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_hour);
 105:../Source - Copy/command.c **** 	strcat(ptr, ":");
 106:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_min);
 107:../Source - Copy/command.c **** 	strcat(ptr, ":");
 108:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_sec);
 109:../Source - Copy/command.c **** 	return 1;
 110:../Source - Copy/command.c **** }
 111:../Source - Copy/command.c **** 
 112:../Source - Copy/command.c **** int append_v9_command(char *buff, char* command) {
 113:../Source - Copy/command.c **** 	strcat(buff, ",V9,");
 114:../Source - Copy/command.c **** 	strcat(buff, command);
 115:../Source - Copy/command.c **** 	return 1;
 116:../Source - Copy/command.c **** }
 117:../Source - Copy/command.c **** 
 118:../Source - Copy/command.c **** int next_char(char* data, char sep, int max) {
 119:../Source - Copy/command.c **** 	char *ptr = strchr(data, sep);
 120:../Source - Copy/command.c **** 	if (ptr) {
 121:../Source - Copy/command.c **** 		return (ptr - data) >= max ? max : (ptr - data);
 122:../Source - Copy/command.c **** 	} else {
 123:../Source - Copy/command.c **** 		return 0;
 124:../Source - Copy/command.c **** 	}
 125:../Source - Copy/command.c **** }
 126:../Source - Copy/command.c **** 
 127:../Source - Copy/command.c **** static char Response[256];
 128:../Source - Copy/command.c **** void create_v3(int blockno) {
 129:../Source - Copy/command.c **** 	append_sign(Response);
 130:../Source - Copy/command.c **** 	strcat(Response, ",V3,");
 131:../Source - Copy/command.c **** 	if (blockno >= 10000) {
 132:../Source - Copy/command.c **** 		append_int(Response, 5, blockno);
 133:../Source - Copy/command.c **** 	} else if (blockno >= 1000) {
 134:../Source - Copy/command.c **** 		append_int(Response, 4, blockno);
 135:../Source - Copy/command.c **** 	} else if (blockno >= 100) {
 136:../Source - Copy/command.c **** 		append_int(Response, 3, blockno);
 137:../Source - Copy/command.c **** 	} else if (blockno >= 10) {
 138:../Source - Copy/command.c **** 		append_int(Response, 2, blockno);
 139:../Source - Copy/command.c **** 	} else {
 140:../Source - Copy/command.c **** 		append_int(Response, 1, blockno);
 141:../Source - Copy/command.c **** 	}
 142:../Source - Copy/command.c **** }
 143:../Source - Copy/command.c **** 
 144:../Source - Copy/command.c **** int write_flash = 0;
 145:../Source - Copy/command.c **** 
 146:../Source - Copy/command.c **** static int sks_cmd_set_debug(int from, char* command, int argc, char** argv, int size, int total) {
 352              		.loc 1 146 0
 353              		.cfi_startproc
 354 0000 13B5     		push	{r0, r1, r4, lr}
 355              	.LCFI5:
 356              		.cfi_def_cfa_offset 16
 357              		.cfi_offset 0, -16
 358              		.cfi_offset 1, -12
 359              		.cfi_offset 4, -8
 360              		.cfi_offset 14, -4
 361              	.LVL32:
 147:../Source - Copy/command.c **** 	//G9, debug setting
 148:../Source - Copy/command.c **** 	//*XX,YYYYYYYYYY,SF,HHMMSS,S#
 149:../Source - Copy/command.c **** 	char set = 0;
 150:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 362              		.loc 1 150 0
 363 0002 1869     		ldr	r0, [r3, #16]
 364              	.LVL33:
 146:../Source - Copy/command.c **** static int sks_cmd_set_debug(int from, char* command, int argc, char** argv, int size, int total) {
 365              		.loc 1 146 0
 366 0004 0C1C     		mov	r4, r1
 367              		.loc 1 150 0
 368 0006 0028     		cmp	r0, #0
 369 0008 11D0     		beq	.L14
 151:../Source - Copy/command.c **** 		return size;
 152:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 370              		.loc 1 152 0
 371 000a FFF7FEFF 		bl	atoi
 372              	.LVL34:
 153:../Source - Copy/command.c **** 
 154:../Source - Copy/command.c **** 	g_appStats.debugOn = set;
 373              		.loc 1 154 0
 374 000e 094A     		ldr	r2, .L15
 152:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 375              		.loc 1 152 0
 376 0010 C0B2     		uxtb	r0, r0
 377              	.LVL35:
 378              		.loc 1 154 0
 379 0012 5932     		add	r2, r2, #89
 155:../Source - Copy/command.c **** 
 156:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d", set, g_appStats.debugOn);
 380              		.loc 1 156 0
 381 0014 8021     		mov	r1, #128
 154:../Source - Copy/command.c **** 	g_appStats.debugOn = set;
 382              		.loc 1 154 0
 383 0016 1070     		strb	r0, [r2]
 384              		.loc 1 156 0
 385 0018 074B     		ldr	r3, .L15+4
 386 001a 0090     		str	r0, [sp]
 387 001c 0190     		str	r0, [sp, #4]
 388 001e 221C     		mov	r2, r4
 389 0020 0648     		ldr	r0, .L15+8
 390              	.LVL36:
 391 0022 4900     		lsl	r1, r1, #1
 392 0024 FFF7FEFF 		bl	cmd_response
 393              	.LVL37:
 157:../Source - Copy/command.c **** 
 158:../Source - Copy/command.c **** 	response = 1;
 394              		.loc 1 158 0
 395 0028 054B     		ldr	r3, .L15+12
 396 002a 0122     		mov	r2, #1
 397 002c 1A60     		str	r2, [r3]
 398              	.L14:
 159:../Source - Copy/command.c **** 
 160:../Source - Copy/command.c **** 	return size;
 161:../Source - Copy/command.c **** }
 399              		.loc 1 161 0
 400 002e 0498     		ldr	r0, [sp, #16]
 401              		@ sp needed for prologue
 402              	.LVL38:
 403 0030 16BD     		pop	{r1, r2, r4, pc}
 404              	.L16:
 405 0032 C046     		.align	2
 406              	.L15:
 407 0034 00000000 		.word	g_appStats
 408 0038 0E000000 		.word	.LC7
 409 003c 00000000 		.word	.LANCHOR1
 410 0040 00000000 		.word	.LANCHOR2
 411              		.cfi_endproc
 412              	.LFE42:
 414              		.section	.text.sks_cmd_set_empty,"ax",%progbits
 415              		.align	1
 416              		.code	16
 417              		.thumb_func
 419              	sks_cmd_set_empty:
 420              	.LFB44:
 162:../Source - Copy/command.c **** 
 163:../Source - Copy/command.c **** static int sks_cmd_set_full(int from, char* command, int argc, char** argv, int size, int total) {
 164:../Source - Copy/command.c **** 	//G9, debug setting
 165:../Source - Copy/command.c **** 	//*XX,YYYYYYYYYY,SF,HHMMSS,S#
 166:../Source - Copy/command.c **** 	char set = 0;
 167:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 168:../Source - Copy/command.c **** 		return size;
 169:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 170:../Source - Copy/command.c **** 
 171:../Source - Copy/command.c **** 	if(set == 1) {
 172:../Source - Copy/command.c **** 		if(argv[5] != NULL) {
 173:../Source - Copy/command.c **** 			g_config.fullValue = atoi(argv[5]);
 174:../Source - Copy/command.c **** 			if(g_config.fullValue == 0) {
 175:../Source - Copy/command.c **** 				g_config.fullValue = g_appStats.frequency;
 176:../Source - Copy/command.c **** 			}
 177:../Source - Copy/command.c **** 		} else {
 178:../Source - Copy/command.c **** 			g_config.fullValue = g_appStats.frequency;
 179:../Source - Copy/command.c **** 		}
 180:../Source - Copy/command.c **** 		write_flash = 1;
 181:../Source - Copy/command.c **** 	}
 182:../Source - Copy/command.c **** 
 183:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d,%d", set, g_config.emptyValue, g_config.f
 184:../Source - Copy/command.c **** 
 185:../Source - Copy/command.c **** 	raise_command_coming();
 186:../Source - Copy/command.c **** 
 187:../Source - Copy/command.c **** 	response = 1;
 188:../Source - Copy/command.c **** 	return size;
 189:../Source - Copy/command.c **** }
 190:../Source - Copy/command.c **** 
 191:../Source - Copy/command.c **** static int sks_cmd_set_empty(int from, char* command, int argc, char** argv, int size, int total) {
 421              		.loc 1 191 0
 422              		.cfi_startproc
 423 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 424              	.LCFI6:
 425              		.cfi_def_cfa_offset 32
 426              		.cfi_offset 0, -32
 427              		.cfi_offset 1, -28
 428              		.cfi_offset 2, -24
 429              		.cfi_offset 3, -20
 430              		.cfi_offset 4, -16
 431              		.cfi_offset 5, -12
 432              		.cfi_offset 6, -8
 433              		.cfi_offset 14, -4
 434              	.LVL39:
 192:../Source - Copy/command.c **** 	//G9, debug setting
 193:../Source - Copy/command.c **** 	//*XX,YYYYYYYYYY,SF,HHMMSS,S#
 194:../Source - Copy/command.c **** 	char set = 0;
 195:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 435              		.loc 1 195 0
 436 0002 1869     		ldr	r0, [r3, #16]
 437              	.LVL40:
 191:../Source - Copy/command.c **** static int sks_cmd_set_empty(int from, char* command, int argc, char** argv, int size, int total) {
 438              		.loc 1 191 0
 439 0004 0E1C     		mov	r6, r1
 440 0006 1C1C     		mov	r4, r3
 441              		.loc 1 195 0
 442 0008 0028     		cmp	r0, #0
 443 000a 25D0     		beq	.L18
 196:../Source - Copy/command.c **** 		return size;
 197:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 444              		.loc 1 197 0
 445 000c FFF7FEFF 		bl	atoi
 446              	.LVL41:
 447 0010 C5B2     		uxtb	r5, r0
 448              	.LVL42:
 198:../Source - Copy/command.c **** 
 199:../Source - Copy/command.c **** 	if(set == 1) {
 449              		.loc 1 199 0
 450 0012 012D     		cmp	r5, #1
 451 0014 0ED1     		bne	.L19
 200:../Source - Copy/command.c **** 		if(argv[5] != NULL) {
 452              		.loc 1 200 0
 453 0016 6069     		ldr	r0, [r4, #20]
 454 0018 114C     		ldr	r4, .L22
 455              	.LVL43:
 456 001a 0028     		cmp	r0, #0
 457 001c 04D0     		beq	.L20
 201:../Source - Copy/command.c **** 			g_config.emptyValue = atoi(argv[5]);
 458              		.loc 1 201 0
 459 001e FFF7FEFF 		bl	atoi
 460 0022 2061     		str	r0, [r4, #16]
 202:../Source - Copy/command.c **** 			if(g_config.emptyValue == 0) {
 461              		.loc 1 202 0
 462 0024 0028     		cmp	r0, #0
 463 0026 02D1     		bne	.L21
 464              	.L20:
 203:../Source - Copy/command.c **** 				g_config.emptyValue = g_appStats.frequency;
 204:../Source - Copy/command.c **** 			}
 205:../Source - Copy/command.c **** 		} else {
 206:../Source - Copy/command.c **** 			g_config.emptyValue = g_appStats.frequency;
 465              		.loc 1 206 0
 466 0028 0E48     		ldr	r0, .L22+4
 467 002a 036A     		ldr	r3, [r0, #32]
 468 002c 2361     		str	r3, [r4, #16]
 469              	.L21:
 207:../Source - Copy/command.c **** 		}
 208:../Source - Copy/command.c **** 		write_flash = 1;
 470              		.loc 1 208 0
 471 002e 0E49     		ldr	r1, .L22+8
 472 0030 0122     		mov	r2, #1
 473 0032 0A60     		str	r2, [r1]
 474              	.L19:
 209:../Source - Copy/command.c **** 	}
 210:../Source - Copy/command.c **** 
 211:../Source - Copy/command.c **** //	append_sign(Response);
 212:../Source - Copy/command.c **** //	append_v9_command(Response, command);
 213:../Source - Copy/command.c **** //	strcat(Response, ",");
 214:../Source - Copy/command.c **** //	append_int(Response, 1, set);
 215:../Source - Copy/command.c **** //	strcat(Response, ",");
 216:../Source - Copy/command.c **** //	append_number(Response, g_config.emptyValue);
 217:../Source - Copy/command.c **** //	strcat(Response, ",");
 218:../Source - Copy/command.c **** //	append_number(Response, g_config.fullValue);
 219:../Source - Copy/command.c **** //	strcat(Response, "#\r\n");
 220:../Source - Copy/command.c **** 
 221:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d,%d", set, g_config.emptyValue, g_config.f
 475              		.loc 1 221 0
 476 0034 0A49     		ldr	r1, .L22
 477 0036 0095     		str	r5, [sp]
 478 0038 0A69     		ldr	r2, [r1, #16]
 479 003a 8023     		mov	r3, #128
 480 003c 0192     		str	r2, [sp, #4]
 481 003e C868     		ldr	r0, [r1, #12]
 482 0040 321C     		mov	r2, r6
 483 0042 5900     		lsl	r1, r3, #1
 484 0044 0290     		str	r0, [sp, #8]
 485 0046 094B     		ldr	r3, .L22+12
 486 0048 0948     		ldr	r0, .L22+16
 487 004a FFF7FEFF 		bl	cmd_response
 222:../Source - Copy/command.c **** 
 223:../Source - Copy/command.c **** 	raise_command_coming();
 488              		.loc 1 223 0
 489 004e FFF7FEFF 		bl	raise_command_coming
 224:../Source - Copy/command.c **** 
 225:../Source - Copy/command.c **** 	response = 1;
 490              		.loc 1 225 0
 491 0052 084D     		ldr	r5, .L22+20
 492              	.LVL44:
 493 0054 0124     		mov	r4, #1
 494 0056 2C60     		str	r4, [r5]
 495              	.L18:
 226:../Source - Copy/command.c **** 	return size;
 227:../Source - Copy/command.c **** }
 496              		.loc 1 227 0
 497 0058 0898     		ldr	r0, [sp, #32]
 498 005a 04B0     		add	sp, sp, #16
 499              		@ sp needed for prologue
 500              	.LVL45:
 501 005c 70BD     		pop	{r4, r5, r6, pc}
 502              	.L23:
 503 005e C046     		.align	2
 504              	.L22:
 505 0060 00000000 		.word	g_config
 506 0064 00000000 		.word	g_appStats
 507 0068 00000000 		.word	.LANCHOR3
 508 006c 14000000 		.word	.LC15
 509 0070 00000000 		.word	.LANCHOR1
 510 0074 00000000 		.word	.LANCHOR2
 511              		.cfi_endproc
 512              	.LFE44:
 514              		.section	.text.sks_cmd_set_full,"ax",%progbits
 515              		.align	1
 516              		.code	16
 517              		.thumb_func
 519              	sks_cmd_set_full:
 520              	.LFB43:
 163:../Source - Copy/command.c **** static int sks_cmd_set_full(int from, char* command, int argc, char** argv, int size, int total) {
 521              		.loc 1 163 0
 522              		.cfi_startproc
 523 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 524              	.LCFI7:
 525              		.cfi_def_cfa_offset 32
 526              		.cfi_offset 0, -32
 527              		.cfi_offset 1, -28
 528              		.cfi_offset 2, -24
 529              		.cfi_offset 3, -20
 530              		.cfi_offset 4, -16
 531              		.cfi_offset 5, -12
 532              		.cfi_offset 6, -8
 533              		.cfi_offset 14, -4
 534              	.LVL46:
 167:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 535              		.loc 1 167 0
 536 0002 1869     		ldr	r0, [r3, #16]
 537              	.LVL47:
 163:../Source - Copy/command.c **** static int sks_cmd_set_full(int from, char* command, int argc, char** argv, int size, int total) {
 538              		.loc 1 163 0
 539 0004 0E1C     		mov	r6, r1
 540 0006 1C1C     		mov	r4, r3
 167:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 541              		.loc 1 167 0
 542 0008 0028     		cmp	r0, #0
 543 000a 25D0     		beq	.L25
 169:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 544              		.loc 1 169 0
 545 000c FFF7FEFF 		bl	atoi
 546              	.LVL48:
 547 0010 C5B2     		uxtb	r5, r0
 548              	.LVL49:
 171:../Source - Copy/command.c **** 	if(set == 1) {
 549              		.loc 1 171 0
 550 0012 012D     		cmp	r5, #1
 551 0014 0ED1     		bne	.L26
 172:../Source - Copy/command.c **** 		if(argv[5] != NULL) {
 552              		.loc 1 172 0
 553 0016 6069     		ldr	r0, [r4, #20]
 554 0018 114C     		ldr	r4, .L29
 555              	.LVL50:
 556 001a 0028     		cmp	r0, #0
 557 001c 04D0     		beq	.L27
 173:../Source - Copy/command.c **** 			g_config.fullValue = atoi(argv[5]);
 558              		.loc 1 173 0
 559 001e FFF7FEFF 		bl	atoi
 560 0022 E060     		str	r0, [r4, #12]
 174:../Source - Copy/command.c **** 			if(g_config.fullValue == 0) {
 561              		.loc 1 174 0
 562 0024 0028     		cmp	r0, #0
 563 0026 02D1     		bne	.L28
 564              	.L27:
 178:../Source - Copy/command.c **** 			g_config.fullValue = g_appStats.frequency;
 565              		.loc 1 178 0
 566 0028 0E48     		ldr	r0, .L29+4
 567 002a 036A     		ldr	r3, [r0, #32]
 568 002c E360     		str	r3, [r4, #12]
 569              	.L28:
 180:../Source - Copy/command.c **** 		write_flash = 1;
 570              		.loc 1 180 0
 571 002e 0E49     		ldr	r1, .L29+8
 572 0030 0122     		mov	r2, #1
 573 0032 0A60     		str	r2, [r1]
 574              	.L26:
 183:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d,%d", set, g_config.emptyValue, g_config.f
 575              		.loc 1 183 0
 576 0034 0A49     		ldr	r1, .L29
 577 0036 0095     		str	r5, [sp]
 578 0038 0A69     		ldr	r2, [r1, #16]
 579 003a 8023     		mov	r3, #128
 580 003c 0192     		str	r2, [sp, #4]
 581 003e C868     		ldr	r0, [r1, #12]
 582 0040 321C     		mov	r2, r6
 583 0042 5900     		lsl	r1, r3, #1
 584 0044 0290     		str	r0, [sp, #8]
 585 0046 094B     		ldr	r3, .L29+12
 586 0048 0948     		ldr	r0, .L29+16
 587 004a FFF7FEFF 		bl	cmd_response
 185:../Source - Copy/command.c **** 	raise_command_coming();
 588              		.loc 1 185 0
 589 004e FFF7FEFF 		bl	raise_command_coming
 187:../Source - Copy/command.c **** 	response = 1;
 590              		.loc 1 187 0
 591 0052 084D     		ldr	r5, .L29+20
 592              	.LVL51:
 593 0054 0124     		mov	r4, #1
 594 0056 2C60     		str	r4, [r5]
 595              	.L25:
 189:../Source - Copy/command.c **** }
 596              		.loc 1 189 0
 597 0058 0898     		ldr	r0, [sp, #32]
 598 005a 04B0     		add	sp, sp, #16
 599              		@ sp needed for prologue
 600              	.LVL52:
 601 005c 70BD     		pop	{r4, r5, r6, pc}
 602              	.L30:
 603 005e C046     		.align	2
 604              	.L29:
 605 0060 00000000 		.word	g_config
 606 0064 00000000 		.word	g_appStats
 607 0068 00000000 		.word	.LANCHOR3
 608 006c 14000000 		.word	.LC15
 609 0070 00000000 		.word	.LANCHOR1
 610 0074 00000000 		.word	.LANCHOR2
 611              		.cfi_endproc
 612              	.LFE43:
 614              		.section	.text.sks_cmd_reset,"ax",%progbits
 615              		.align	1
 616              		.code	16
 617              		.thumb_func
 619              	sks_cmd_reset:
 620              	.LFB48:
 228:../Source - Copy/command.c **** 
 229:../Source - Copy/command.c **** static int sks_cmd_interval(int from, char* command, int argc, char** argv, int size, int total) {
 230:../Source - Copy/command.c **** 	//G9, debug setting
 231:../Source - Copy/command.c **** 	//*XX,YYYYYYYYYY,SF,HHMMSS,S#
 232:../Source - Copy/command.c **** 	char set = 0;
 233:../Source - Copy/command.c **** 
 234:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 235:../Source - Copy/command.c **** 		return size;
 236:../Source - Copy/command.c **** 
 237:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 238:../Source - Copy/command.c **** 
 239:../Source - Copy/command.c **** 	if(set == 1) {
 240:../Source - Copy/command.c **** 		if(argv[5] != NULL) {
 241:../Source - Copy/command.c **** 			g_config.interval = atoi(argv[5]);
 242:../Source - Copy/command.c **** 		}
 243:../Source - Copy/command.c **** 
 244:../Source - Copy/command.c **** 		write_flash = 1;
 245:../Source - Copy/command.c **** 	}
 246:../Source - Copy/command.c **** 
 247:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d", set, g_config.interval);
 248:../Source - Copy/command.c **** 
 249:../Source - Copy/command.c **** 	raise_command_coming();
 250:../Source - Copy/command.c **** 
 251:../Source - Copy/command.c **** 	response = 1;
 252:../Source - Copy/command.c **** 	return size;
 253:../Source - Copy/command.c **** }
 254:../Source - Copy/command.c **** 
 255:../Source - Copy/command.c **** static int sks_cmd_config(int from, char* command, int argc, char** argv, int size, int total) {
 256:../Source - Copy/command.c **** 	//G9, debug setting
 257:../Source - Copy/command.c **** 	//*XX,YYYYYYYYYY,SF,HHMMSS,S#
 258:../Source - Copy/command.c **** 	char set = 0;
 259:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 260:../Source - Copy/command.c **** 		return size;
 261:../Source - Copy/command.c **** 
 262:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 263:../Source - Copy/command.c **** 
 264:../Source - Copy/command.c **** 	if(set == 1) {
 265:../Source - Copy/command.c **** 		if(argv[5] != NULL) {
 266:../Source - Copy/command.c **** 			g_config.timeout3D = atoi(argv[5]);
 267:../Source - Copy/command.c **** 		}
 268:../Source - Copy/command.c **** 
 269:../Source - Copy/command.c **** 		if(argv[6] != NULL) {
 270:../Source - Copy/command.c **** 			g_config.filterMode = atoi(argv[6]);
 271:../Source - Copy/command.c **** 		}
 272:../Source - Copy/command.c **** 
 273:../Source - Copy/command.c **** 		if(argv[7] != NULL) {
 274:../Source - Copy/command.c **** 			int diffX = atoi(argv[7]);
 275:../Source - Copy/command.c **** 			if(diffX >= 3 && diffX <= 30) {
 276:../Source - Copy/command.c **** 				g_config.diffX = diffX;
 277:../Source - Copy/command.c **** 			}
 278:../Source - Copy/command.c **** 		}
 279:../Source - Copy/command.c **** 
 280:../Source - Copy/command.c **** 		if(argv[8] != NULL) {
 281:../Source - Copy/command.c **** 			int diffY = atoi(argv[8]);
 282:../Source - Copy/command.c **** 			if(diffY >= 3 && diffY <= 30) {
 283:../Source - Copy/command.c **** 				g_config.diffY = diffY;
 284:../Source - Copy/command.c **** 			}
 285:../Source - Copy/command.c **** 		}
 286:../Source - Copy/command.c **** 
 287:../Source - Copy/command.c **** 		write_flash = 1;
 288:../Source - Copy/command.c **** 	}
 289:../Source - Copy/command.c **** 
 290:../Source - Copy/command.c **** //	append_sign(Response);
 291:../Source - Copy/command.c **** //	append_v9_command(Response, command);
 292:../Source - Copy/command.c **** //	strcat(Response, ",");
 293:../Source - Copy/command.c **** //	append_int(Response, 1, set);
 294:../Source - Copy/command.c **** //	strcat(Response, ",");
 295:../Source - Copy/command.c **** //	append_int(Response, 2, g_config.timeout3D);
 296:../Source - Copy/command.c **** //	strcat(Response, ",");
 297:../Source - Copy/command.c **** //	append_int(Response, 1, g_config.filterMode);
 298:../Source - Copy/command.c **** //	strcat(Response, ",");
 299:../Source - Copy/command.c **** //	append_int(Response, 2, g_config.diffX);
 300:../Source - Copy/command.c **** //	strcat(Response, ",");
 301:../Source - Copy/command.c **** //	append_int(Response, 2, g_config.diffY);
 302:../Source - Copy/command.c **** //	strcat(Response, "#\r\n");
 303:../Source - Copy/command.c **** 
 304:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d,%d,%d,%d", set, g_config.timeout3D, g_con
 305:../Source - Copy/command.c **** 
 306:../Source - Copy/command.c **** 	response = 1;
 307:../Source - Copy/command.c **** 	return size;
 308:../Source - Copy/command.c **** }
 309:../Source - Copy/command.c **** 
 310:../Source - Copy/command.c **** static int sks_cmd_serial(int from, char* command, int argc, char** argv, int size, int total) {
 311:../Source - Copy/command.c **** 	//G9, debug setting
 312:../Source - Copy/command.c **** 	//*XX,YYYYYYYYYY,SF,HHMMSS,S#
 313:../Source - Copy/command.c **** 	char set = 0;
 314:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 315:../Source - Copy/command.c **** 		return size;
 316:../Source - Copy/command.c **** 
 317:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 318:../Source - Copy/command.c **** 
 319:../Source - Copy/command.c **** 	if(set == 1) {
 320:../Source - Copy/command.c **** 		memset(g_config.deviceCode, 0, sizeof(g_config.deviceCode));
 321:../Source - Copy/command.c **** 		strncpy(g_config.deviceCode, argv[5], next_char(argv[5], '#', DEVICE_CODE_LEN));
 322:../Source - Copy/command.c **** 
 323:../Source - Copy/command.c **** 		write_flash = 1;
 324:../Source - Copy/command.c **** 	}
 325:../Source - Copy/command.c **** 
 326:../Source - Copy/command.c **** //	append_sign(Response);
 327:../Source - Copy/command.c **** //	append_v9_command(Response, command);
 328:../Source - Copy/command.c **** //	strcat(Response, ",");
 329:../Source - Copy/command.c **** //	append_int(Response, 1, set);
 330:../Source - Copy/command.c **** //	strcat(Response, ",");
 331:../Source - Copy/command.c **** //	strcat(Response, g_config.deviceCode);
 332:../Source - Copy/command.c **** //	strcat(Response, "#\r\n");
 333:../Source - Copy/command.c **** 
 334:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%s", set, g_config.deviceCode);
 335:../Source - Copy/command.c **** 
 336:../Source - Copy/command.c **** 	response = 1;
 337:../Source - Copy/command.c **** 	return size;
 338:../Source - Copy/command.c **** }
 339:../Source - Copy/command.c **** 
 340:../Source - Copy/command.c **** static int sks_cmd_reset(int from, char* command, int argc, char** argv, int size, int total) {
 621              		.loc 1 340 0
 622              		.cfi_startproc
 623 0000 13B5     		push	{r0, r1, r4, lr}
 624              	.LCFI8:
 625              		.cfi_def_cfa_offset 16
 626              		.cfi_offset 0, -16
 627              		.cfi_offset 1, -12
 628              		.cfi_offset 4, -8
 629              		.cfi_offset 14, -4
 630              	.LVL53:
 341:../Source - Copy/command.c **** 	//G9, debug setting
 342:../Source - Copy/command.c **** 	//*XX,YYYYYYYYYY,SF,HHMMSS,S#
 343:../Source - Copy/command.c **** 	char set = 0;
 344:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 631              		.loc 1 344 0
 632 0002 1869     		ldr	r0, [r3, #16]
 633              	.LVL54:
 340:../Source - Copy/command.c **** static int sks_cmd_reset(int from, char* command, int argc, char** argv, int size, int total) {
 634              		.loc 1 340 0
 635 0004 0C1C     		mov	r4, r1
 636              		.loc 1 344 0
 637 0006 0028     		cmp	r0, #0
 638 0008 13D0     		beq	.L32
 345:../Source - Copy/command.c **** 		return size;
 346:../Source - Copy/command.c **** 
 347:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 639              		.loc 1 347 0
 640 000a FFF7FEFF 		bl	atoi
 641              	.LVL55:
 642 000e C0B2     		uxtb	r0, r0
 643              	.LVL56:
 348:../Source - Copy/command.c **** 
 349:../Source - Copy/command.c **** 	if(set == 1) {
 644              		.loc 1 349 0
 645 0010 0128     		cmp	r0, #1
 646 0012 03D1     		bne	.L33
 350:../Source - Copy/command.c **** 		g_appStats.resetNow = ulSecCount;
 647              		.loc 1 350 0
 648 0014 0849     		ldr	r1, .L34
 649 0016 094B     		ldr	r3, .L34+4
 650 0018 0A68     		ldr	r2, [r1]
 651 001a DA65     		str	r2, [r3, #92]
 652              	.L33:
 351:../Source - Copy/command.c **** 	}
 352:../Source - Copy/command.c **** 
 353:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d", set);
 653              		.loc 1 353 0
 654 001c 8022     		mov	r2, #128
 655 001e 0090     		str	r0, [sp]
 656 0020 5100     		lsl	r1, r2, #1
 657 0022 0748     		ldr	r0, .L34+8
 658              	.LVL57:
 659 0024 221C     		mov	r2, r4
 660 0026 074B     		ldr	r3, .L34+12
 661 0028 FFF7FEFF 		bl	cmd_response
 662              	.LVL58:
 354:../Source - Copy/command.c **** 
 355:../Source - Copy/command.c **** 	response = 1;
 663              		.loc 1 355 0
 664 002c 064C     		ldr	r4, .L34+16
 665              	.LVL59:
 666 002e 0120     		mov	r0, #1
 667 0030 2060     		str	r0, [r4]
 668              	.L32:
 356:../Source - Copy/command.c **** 	return size;
 357:../Source - Copy/command.c **** }
 669              		.loc 1 357 0
 670 0032 0498     		ldr	r0, [sp, #16]
 671              		@ sp needed for prologue
 672 0034 16BD     		pop	{r1, r2, r4, pc}
 673              	.L35:
 674 0036 C046     		.align	2
 675              	.L34:
 676 0038 00000000 		.word	ulSecCount
 677 003c 00000000 		.word	g_appStats
 678 0040 00000000 		.word	.LANCHOR1
 679 0044 1D000000 		.word	.LC29
 680 0048 00000000 		.word	.LANCHOR2
 681              		.cfi_endproc
 682              	.LFE48:
 684              		.section	.text.sks_cmd_interval,"ax",%progbits
 685              		.align	1
 686              		.code	16
 687              		.thumb_func
 689              	sks_cmd_interval:
 690              	.LFB45:
 229:../Source - Copy/command.c **** static int sks_cmd_interval(int from, char* command, int argc, char** argv, int size, int total) {
 691              		.loc 1 229 0
 692              		.cfi_startproc
 693 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 694              	.LCFI9:
 695              		.cfi_def_cfa_offset 24
 696              		.cfi_offset 0, -24
 697              		.cfi_offset 1, -20
 698              		.cfi_offset 4, -16
 699              		.cfi_offset 5, -12
 700              		.cfi_offset 6, -8
 701              		.cfi_offset 14, -4
 702              	.LVL60:
 234:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 703              		.loc 1 234 0
 704 0002 1869     		ldr	r0, [r3, #16]
 705              	.LVL61:
 229:../Source - Copy/command.c **** static int sks_cmd_interval(int from, char* command, int argc, char** argv, int size, int total) {
 706              		.loc 1 229 0
 707 0004 0E1C     		mov	r6, r1
 708 0006 1C1C     		mov	r4, r3
 234:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 709              		.loc 1 234 0
 710 0008 0028     		cmp	r0, #0
 711 000a 1ED0     		beq	.L37
 237:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 712              		.loc 1 237 0
 713 000c FFF7FEFF 		bl	atoi
 714              	.LVL62:
 715 0010 C5B2     		uxtb	r5, r0
 716              	.LVL63:
 239:../Source - Copy/command.c **** 	if(set == 1) {
 717              		.loc 1 239 0
 718 0012 012D     		cmp	r5, #1
 719 0014 09D1     		bne	.L38
 240:../Source - Copy/command.c **** 		if(argv[5] != NULL) {
 720              		.loc 1 240 0
 721 0016 6069     		ldr	r0, [r4, #20]
 722 0018 0028     		cmp	r0, #0
 723 001a 03D0     		beq	.L39
 241:../Source - Copy/command.c **** 			g_config.interval = atoi(argv[5]);
 724              		.loc 1 241 0
 725 001c FFF7FEFF 		bl	atoi
 726 0020 0B4B     		ldr	r3, .L40
 727 0022 9876     		strb	r0, [r3, #26]
 728              	.L39:
 244:../Source - Copy/command.c **** 		write_flash = 1;
 729              		.loc 1 244 0
 730 0024 0B48     		ldr	r0, .L40+4
 731 0026 0122     		mov	r2, #1
 732 0028 0260     		str	r2, [r0]
 733              	.L38:
 247:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d", set, g_config.interval);
 734              		.loc 1 247 0
 735 002a 094A     		ldr	r2, .L40
 736 002c 0095     		str	r5, [sp]
 737 002e 937E     		ldrb	r3, [r2, #26]
 738 0030 8025     		mov	r5, #128
 739              	.LVL64:
 740 0032 6900     		lsl	r1, r5, #1
 741 0034 0193     		str	r3, [sp, #4]
 742 0036 321C     		mov	r2, r6
 743 0038 074B     		ldr	r3, .L40+8
 744 003a 0848     		ldr	r0, .L40+12
 745 003c FFF7FEFF 		bl	cmd_response
 746              	.LVL65:
 249:../Source - Copy/command.c **** 	raise_command_coming();
 747              		.loc 1 249 0
 748 0040 FFF7FEFF 		bl	raise_command_coming
 251:../Source - Copy/command.c **** 	response = 1;
 749              		.loc 1 251 0
 750 0044 064C     		ldr	r4, .L40+16
 751              	.LVL66:
 752 0046 0121     		mov	r1, #1
 753 0048 2160     		str	r1, [r4]
 754              	.L37:
 253:../Source - Copy/command.c **** }
 755              		.loc 1 253 0
 756 004a 0698     		ldr	r0, [sp, #24]
 757              		@ sp needed for prologue
 758              	.LVL67:
 759 004c 76BD     		pop	{r1, r2, r4, r5, r6, pc}
 760              	.L41:
 761 004e C046     		.align	2
 762              	.L40:
 763 0050 00000000 		.word	g_config
 764 0054 00000000 		.word	.LANCHOR3
 765 0058 0E000000 		.word	.LC7
 766 005c 00000000 		.word	.LANCHOR1
 767 0060 00000000 		.word	.LANCHOR2
 768              		.cfi_endproc
 769              	.LFE45:
 771              		.section	.text.sks_cmd_info,"ax",%progbits
 772              		.align	1
 773              		.code	16
 774              		.thumb_func
 776              	sks_cmd_info:
 777              	.LFB49:
 358:../Source - Copy/command.c **** 
 359:../Source - Copy/command.c **** static int sks_cmd_info(int from, char* command, int argc, char** argv, int size, int total) {
 778              		.loc 1 359 0
 779              		.cfi_startproc
 780 0000 10B5     		push	{r4, lr}
 781              	.LCFI10:
 782              		.cfi_def_cfa_offset 8
 783              		.cfi_offset 4, -8
 784              		.cfi_offset 14, -4
 785              	.LVL68:
 360:../Source - Copy/command.c **** 	//G9, debug setting
 361:../Source - Copy/command.c **** 	//*XX,YYYYYYYYYY,SF,HHMMSS,S#
 362:../Source - Copy/command.c **** 	char set = 0;
 363:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 786              		.loc 1 363 0
 787 0002 1869     		ldr	r0, [r3, #16]
 788              	.LVL69:
 359:../Source - Copy/command.c **** static int sks_cmd_info(int from, char* command, int argc, char** argv, int size, int total) {
 789              		.loc 1 359 0
 790 0004 88B0     		sub	sp, sp, #32
 791              	.LCFI11:
 792              		.cfi_def_cfa_offset 40
 359:../Source - Copy/command.c **** static int sks_cmd_info(int from, char* command, int argc, char** argv, int size, int total) {
 793              		.loc 1 359 0
 794 0006 0C1C     		mov	r4, r1
 795              		.loc 1 363 0
 796 0008 0028     		cmp	r0, #0
 797 000a 1CD0     		beq	.L43
 364:../Source - Copy/command.c **** 		return size;
 365:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 798              		.loc 1 365 0
 799 000c FFF7FEFF 		bl	atoi
 800              	.LVL70:
 366:../Source - Copy/command.c **** 
 367:../Source - Copy/command.c **** 	if(set == 1) {
 368:../Source - Copy/command.c **** 	}
 369:../Source - Copy/command.c **** 
 370:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d,%d,%d,%d,%s,%s", set, g_config.interval, 
 801              		.loc 1 370 0
 802 0010 C3B2     		uxtb	r3, r0
 803 0012 0093     		str	r3, [sp]
 804 0014 0D4B     		ldr	r3, .L44
 805 0016 9A7E     		ldrb	r2, [r3, #26]
 806 0018 0192     		str	r2, [sp, #4]
 807 001a D87D     		ldrb	r0, [r3, #23]
 808              	.LVL71:
 809 001c 0290     		str	r0, [sp, #8]
 810 001e 1969     		ldr	r1, [r3, #16]
 811 0020 0B48     		ldr	r0, .L44+4
 812 0022 0391     		str	r1, [sp, #12]
 813 0024 DA68     		ldr	r2, [r3, #12]
 814 0026 8021     		mov	r1, #128
 815 0028 0233     		add	r3, r3, #2
 816 002a 0492     		str	r2, [sp, #16]
 817 002c 0593     		str	r3, [sp, #20]
 818 002e 221C     		mov	r2, r4
 819 0030 084B     		ldr	r3, .L44+8
 820 0032 0690     		str	r0, [sp, #24]
 821 0034 4900     		lsl	r1, r1, #1
 822 0036 0848     		ldr	r0, .L44+12
 823 0038 FFF7FEFF 		bl	cmd_response
 371:../Source - Copy/command.c **** 
 372:../Source - Copy/command.c **** 	raise_command_coming();
 824              		.loc 1 372 0
 825 003c FFF7FEFF 		bl	raise_command_coming
 373:../Source - Copy/command.c **** 
 374:../Source - Copy/command.c **** 	response = 1;
 826              		.loc 1 374 0
 827 0040 064B     		ldr	r3, .L44+16
 828 0042 0122     		mov	r2, #1
 829 0044 1A60     		str	r2, [r3]
 830              	.L43:
 375:../Source - Copy/command.c **** 	return size;
 376:../Source - Copy/command.c **** }
 831              		.loc 1 376 0
 832 0046 0A98     		ldr	r0, [sp, #40]
 833 0048 08B0     		add	sp, sp, #32
 834              		@ sp needed for prologue
 835              	.LVL72:
 836 004a 10BD     		pop	{r4, pc}
 837              	.L45:
 838              		.align	2
 839              	.L44:
 840 004c 00000000 		.word	g_config
 841 0050 35000000 		.word	.LC42
 842 0054 20000000 		.word	.LC38
 843 0058 00000000 		.word	.LANCHOR1
 844 005c 00000000 		.word	.LANCHOR2
 845              		.cfi_endproc
 846              	.LFE49:
 848              		.section	.text.sks_cmd_config,"ax",%progbits
 849              		.align	1
 850              		.code	16
 851              		.thumb_func
 853              	sks_cmd_config:
 854              	.LFB46:
 255:../Source - Copy/command.c **** static int sks_cmd_config(int from, char* command, int argc, char** argv, int size, int total) {
 855              		.loc 1 255 0
 856              		.cfi_startproc
 857 0000 70B5     		push	{r4, r5, r6, lr}
 858              	.LCFI12:
 859              		.cfi_def_cfa_offset 16
 860              		.cfi_offset 4, -16
 861              		.cfi_offset 5, -12
 862              		.cfi_offset 6, -8
 863              		.cfi_offset 14, -4
 864              	.LVL73:
 259:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 865              		.loc 1 259 0
 866 0002 1869     		ldr	r0, [r3, #16]
 867              	.LVL74:
 255:../Source - Copy/command.c **** static int sks_cmd_config(int from, char* command, int argc, char** argv, int size, int total) {
 868              		.loc 1 255 0
 869 0004 86B0     		sub	sp, sp, #24
 870              	.LCFI13:
 871              		.cfi_def_cfa_offset 40
 255:../Source - Copy/command.c **** static int sks_cmd_config(int from, char* command, int argc, char** argv, int size, int total) {
 872              		.loc 1 255 0
 873 0006 0E1C     		mov	r6, r1
 874 0008 1C1C     		mov	r4, r3
 259:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 875              		.loc 1 259 0
 876 000a 0028     		cmp	r0, #0
 877 000c 3DD0     		beq	.L47
 262:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 878              		.loc 1 262 0
 879 000e FFF7FEFF 		bl	atoi
 880              	.LVL75:
 881 0012 C5B2     		uxtb	r5, r0
 882              	.LVL76:
 264:../Source - Copy/command.c **** 	if(set == 1) {
 883              		.loc 1 264 0
 884 0014 012D     		cmp	r5, #1
 885 0016 24D1     		bne	.L48
 265:../Source - Copy/command.c **** 		if(argv[5] != NULL) {
 886              		.loc 1 265 0
 887 0018 6069     		ldr	r0, [r4, #20]
 888 001a 0028     		cmp	r0, #0
 889 001c 03D0     		beq	.L49
 266:../Source - Copy/command.c **** 			g_config.timeout3D = atoi(argv[5]);
 890              		.loc 1 266 0
 891 001e FFF7FEFF 		bl	atoi
 892 0022 1B4B     		ldr	r3, .L53
 893 0024 9882     		strh	r0, [r3, #20]
 894              	.L49:
 269:../Source - Copy/command.c **** 		if(argv[6] != NULL) {
 895              		.loc 1 269 0
 896 0026 A069     		ldr	r0, [r4, #24]
 897 0028 0028     		cmp	r0, #0
 898 002a 03D0     		beq	.L50
 270:../Source - Copy/command.c **** 			g_config.filterMode = atoi(argv[6]);
 899              		.loc 1 270 0
 900 002c FFF7FEFF 		bl	atoi
 901 0030 1749     		ldr	r1, .L53
 902 0032 C875     		strb	r0, [r1, #23]
 903              	.L50:
 273:../Source - Copy/command.c **** 		if(argv[7] != NULL) {
 904              		.loc 1 273 0
 905 0034 E069     		ldr	r0, [r4, #28]
 906 0036 0028     		cmp	r0, #0
 907 0038 06D0     		beq	.L51
 908              	.LBB2:
 274:../Source - Copy/command.c **** 			int diffX = atoi(argv[7]);
 909              		.loc 1 274 0
 910 003a FFF7FEFF 		bl	atoi
 911              	.LVL77:
 275:../Source - Copy/command.c **** 			if(diffX >= 3 && diffX <= 30) {
 912              		.loc 1 275 0
 913 003e C21E     		sub	r2, r0, #3
 914 0040 1B2A     		cmp	r2, #27
 915 0042 01D8     		bhi	.L51
 276:../Source - Copy/command.c **** 				g_config.diffX = diffX;
 916              		.loc 1 276 0
 917 0044 124B     		ldr	r3, .L53
 918 0046 1876     		strb	r0, [r3, #24]
 919              	.LVL78:
 920              	.L51:
 921              	.LBE2:
 280:../Source - Copy/command.c **** 		if(argv[8] != NULL) {
 922              		.loc 1 280 0
 923 0048 206A     		ldr	r0, [r4, #32]
 924 004a 0028     		cmp	r0, #0
 925 004c 06D0     		beq	.L52
 926              	.LBB3:
 281:../Source - Copy/command.c **** 			int diffY = atoi(argv[8]);
 927              		.loc 1 281 0
 928 004e FFF7FEFF 		bl	atoi
 929              	.LVL79:
 282:../Source - Copy/command.c **** 			if(diffY >= 3 && diffY <= 30) {
 930              		.loc 1 282 0
 931 0052 C41E     		sub	r4, r0, #3
 932              	.LVL80:
 933 0054 1B2C     		cmp	r4, #27
 934 0056 01D8     		bhi	.L52
 283:../Source - Copy/command.c **** 				g_config.diffY = diffY;
 935              		.loc 1 283 0
 936 0058 0D49     		ldr	r1, .L53
 937 005a 4876     		strb	r0, [r1, #25]
 938              	.LVL81:
 939              	.L52:
 940              	.LBE3:
 287:../Source - Copy/command.c **** 		write_flash = 1;
 941              		.loc 1 287 0
 942 005c 0D4A     		ldr	r2, .L53+4
 943 005e 0120     		mov	r0, #1
 944 0060 1060     		str	r0, [r2]
 945              	.L48:
 304:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d,%d,%d,%d", set, g_config.timeout3D, g_con
 946              		.loc 1 304 0
 947 0062 0B49     		ldr	r1, .L53
 948 0064 0095     		str	r5, [sp]
 949 0066 8D8A     		ldrh	r5, [r1, #20]
 950              	.LVL82:
 951 0068 8023     		mov	r3, #128
 952 006a 0195     		str	r5, [sp, #4]
 953 006c CA7D     		ldrb	r2, [r1, #23]
 306:../Source - Copy/command.c **** 	response = 1;
 954              		.loc 1 306 0
 955 006e 0125     		mov	r5, #1
 304:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%d,%d,%d,%d", set, g_config.timeout3D, g_con
 956              		.loc 1 304 0
 957 0070 0292     		str	r2, [sp, #8]
 958 0072 087E     		ldrb	r0, [r1, #24]
 959 0074 321C     		mov	r2, r6
 960 0076 0390     		str	r0, [sp, #12]
 961 0078 4C7E     		ldrb	r4, [r1, #25]
 962 007a 0748     		ldr	r0, .L53+8
 963 007c 5900     		lsl	r1, r3, #1
 964 007e 074B     		ldr	r3, .L53+12
 965 0080 0494     		str	r4, [sp, #16]
 966 0082 FFF7FEFF 		bl	cmd_response
 967              	.LVL83:
 306:../Source - Copy/command.c **** 	response = 1;
 968              		.loc 1 306 0
 969 0086 064E     		ldr	r6, .L53+16
 970              	.LVL84:
 971 0088 3560     		str	r5, [r6]
 972              	.L47:
 308:../Source - Copy/command.c **** }
 973              		.loc 1 308 0
 974 008a 0A98     		ldr	r0, [sp, #40]
 975 008c 06B0     		add	sp, sp, #24
 976              		@ sp needed for prologue
 977 008e 70BD     		pop	{r4, r5, r6, pc}
 978              	.L54:
 979              		.align	2
 980              	.L53:
 981 0090 00000000 		.word	g_config
 982 0094 00000000 		.word	.LANCHOR3
 983 0098 00000000 		.word	.LANCHOR1
 984 009c 4A000000 		.word	.LC48
 985 00a0 00000000 		.word	.LANCHOR2
 986              		.cfi_endproc
 987              	.LFE46:
 989              		.section	.text.append_sign,"ax",%progbits
 990              		.align	1
 991              		.global	append_sign
 992              		.code	16
 993              		.thumb_func
 995              	append_sign:
 996              	.LFB37:
  88:../Source - Copy/command.c **** int append_sign(char* buff) {
 997              		.loc 1 88 0
 998              		.cfi_startproc
 999 0000 10B5     		push	{r4, lr}
 1000              	.LCFI14:
 1001              		.cfi_def_cfa_offset 8
 1002              		.cfi_offset 4, -8
 1003              		.cfi_offset 14, -4
 1004              	.LVL85:
  88:../Source - Copy/command.c **** int append_sign(char* buff) {
 1005              		.loc 1 88 0
 1006 0002 041C     		mov	r4, r0
  89:../Source - Copy/command.c **** 	strcpy(buff, "*SS,");
 1007              		.loc 1 89 0
 1008 0004 0449     		ldr	r1, .L56
 1009 0006 FFF7FEFF 		bl	strcpy
 1010              	.LVL86:
  90:../Source - Copy/command.c **** 	strcat(buff, (char*)g_config.deviceCode);
 1011              		.loc 1 90 0
 1012 000a 201C     		mov	r0, r4
 1013 000c 0349     		ldr	r1, .L56+4
 1014 000e FFF7FEFF 		bl	strcat
 1015              		@ sp needed for prologue
  92:../Source - Copy/command.c **** }
 1016              		.loc 1 92 0
 1017 0012 0120     		mov	r0, #1
 1018              	.LVL87:
 1019 0014 10BD     		pop	{r4, pc}
 1020              	.L57:
 1021 0016 C046     		.align	2
 1022              	.L56:
 1023 0018 59000000 		.word	.LC51
 1024 001c 02000000 		.word	g_config+2
 1025              		.cfi_endproc
 1026              	.LFE37:
 1028              		.section	.text.append_time,"ax",%progbits
 1029              		.align	1
 1030              		.global	append_time
 1031              		.code	16
 1032              		.thumb_func
 1034              	append_time:
 1035              	.LFB38:
  94:../Source - Copy/command.c **** int append_time(char* buff, time_t ti) {
 1036              		.loc 1 94 0
 1037              		.cfi_startproc
 1038 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1039              	.LCFI15:
 1040              		.cfi_def_cfa_offset 24
 1041              		.cfi_offset 0, -24
 1042              		.cfi_offset 1, -20
 1043              		.cfi_offset 4, -16
 1044              		.cfi_offset 5, -12
 1045              		.cfi_offset 6, -8
 1046              		.cfi_offset 14, -4
 1047              	.LVL88:
  94:../Source - Copy/command.c **** int append_time(char* buff, time_t ti) {
 1048              		.loc 1 94 0
 1049 0002 051C     		mov	r5, r0
  96:../Source - Copy/command.c **** 	struct tm *tm = gmtime(&now);
 1050              		.loc 1 96 0
 1051 0004 01A8     		add	r0, sp, #4
 1052              	.LVL89:
  95:../Source - Copy/command.c **** 	time_t now = ti;
 1053              		.loc 1 95 0
 1054 0006 0191     		str	r1, [sp, #4]
 1055              	.LVL90:
  96:../Source - Copy/command.c **** 	struct tm *tm = gmtime(&now);
 1056              		.loc 1 96 0
 1057 0008 FFF7FEFF 		bl	gmtime
 1058              	.LVL91:
 1059 000c 041C     		mov	r4, r0
 1060              	.LVL92:
  97:../Source - Copy/command.c **** 	char *ptr = buff + strlen(buff);
 1061              		.loc 1 97 0
 1062 000e 281C     		mov	r0, r5
 1063              	.LVL93:
 1064 0010 FFF7FEFF 		bl	strlen
  98:../Source - Copy/command.c **** 	append_int(ptr, 4, tm->tm_year + 1900);
 1065              		.loc 1 98 0
 1066 0014 1C4B     		ldr	r3, .L59
 1067 0016 6269     		ldr	r2, [r4, #20]
  97:../Source - Copy/command.c **** 	char *ptr = buff + strlen(buff);
 1068              		.loc 1 97 0
 1069 0018 2D18     		add	r5, r5, r0
 1070              	.LVL94:
  98:../Source - Copy/command.c **** 	append_int(ptr, 4, tm->tm_year + 1900);
 1071              		.loc 1 98 0
 1072 001a D218     		add	r2, r2, r3
 1073 001c 281C     		mov	r0, r5
 1074 001e 0421     		mov	r1, #4
 1075 0020 FFF7FEFF 		bl	append_int
  99:../Source - Copy/command.c **** 	strcat(ptr, "-");
 1076              		.loc 1 99 0
 1077 0024 194E     		ldr	r6, .L59+4
 1078 0026 281C     		mov	r0, r5
 1079 0028 311C     		mov	r1, r6
 1080 002a FFF7FEFF 		bl	strcat
 100:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_mon + 1);
 1081              		.loc 1 100 0
 1082 002e 2269     		ldr	r2, [r4, #16]
 1083 0030 281C     		mov	r0, r5
 1084 0032 0132     		add	r2, r2, #1
 1085 0034 0221     		mov	r1, #2
 1086 0036 FFF7FEFF 		bl	append_int
 101:../Source - Copy/command.c **** 	strcat(ptr, "-");
 1087              		.loc 1 101 0
 1088 003a 281C     		mov	r0, r5
 1089 003c 311C     		mov	r1, r6
 1090 003e FFF7FEFF 		bl	strcat
 102:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_mday);
 1091              		.loc 1 102 0
 1092 0042 281C     		mov	r0, r5
 1093 0044 E268     		ldr	r2, [r4, #12]
 1094 0046 0221     		mov	r1, #2
 1095 0048 FFF7FEFF 		bl	append_int
 103:../Source - Copy/command.c **** 	strcat(ptr, " ");
 1096              		.loc 1 103 0
 1097 004c 281C     		mov	r0, r5
 1098 004e 1049     		ldr	r1, .L59+8
 1099 0050 FFF7FEFF 		bl	strcat
 104:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_hour);
 1100              		.loc 1 104 0
 1101 0054 281C     		mov	r0, r5
 1102 0056 A268     		ldr	r2, [r4, #8]
 1103 0058 0221     		mov	r1, #2
 1104 005a FFF7FEFF 		bl	append_int
 105:../Source - Copy/command.c **** 	strcat(ptr, ":");
 1105              		.loc 1 105 0
 1106 005e 0D4E     		ldr	r6, .L59+12
 1107 0060 281C     		mov	r0, r5
 1108 0062 311C     		mov	r1, r6
 1109 0064 FFF7FEFF 		bl	strcat
 106:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_min);
 1110              		.loc 1 106 0
 1111 0068 281C     		mov	r0, r5
 1112 006a 6268     		ldr	r2, [r4, #4]
 1113 006c 0221     		mov	r1, #2
 1114 006e FFF7FEFF 		bl	append_int
 107:../Source - Copy/command.c **** 	strcat(ptr, ":");
 1115              		.loc 1 107 0
 1116 0072 311C     		mov	r1, r6
 1117 0074 281C     		mov	r0, r5
 1118 0076 FFF7FEFF 		bl	strcat
 108:../Source - Copy/command.c **** 	append_int(ptr, 2, tm->tm_sec);
 1119              		.loc 1 108 0
 1120 007a 281C     		mov	r0, r5
 1121 007c 0221     		mov	r1, #2
 1122 007e 2268     		ldr	r2, [r4]
 1123 0080 FFF7FEFF 		bl	append_int
 1124              		@ sp needed for prologue
 110:../Source - Copy/command.c **** }
 1125              		.loc 1 110 0
 1126 0084 0120     		mov	r0, #1
 1127              	.LVL95:
 1128              	.LVL96:
 1129 0086 76BD     		pop	{r1, r2, r4, r5, r6, pc}
 1130              	.L60:
 1131              		.align	2
 1132              	.L59:
 1133 0088 6C070000 		.word	1900
 1134 008c 5E000000 		.word	.LC54
 1135 0090 60000000 		.word	.LC56
 1136 0094 62000000 		.word	.LC58
 1137              		.cfi_endproc
 1138              	.LFE38:
 1140              		.section	.text.append_v9_command,"ax",%progbits
 1141              		.align	1
 1142              		.global	append_v9_command
 1143              		.code	16
 1144              		.thumb_func
 1146              	append_v9_command:
 1147              	.LFB39:
 112:../Source - Copy/command.c **** int append_v9_command(char *buff, char* command) {
 1148              		.loc 1 112 0
 1149              		.cfi_startproc
 1150 0000 38B5     		push	{r3, r4, r5, lr}
 1151              	.LCFI16:
 1152              		.cfi_def_cfa_offset 16
 1153              		.cfi_offset 3, -16
 1154              		.cfi_offset 4, -12
 1155              		.cfi_offset 5, -8
 1156              		.cfi_offset 14, -4
 1157              	.LVL97:
 112:../Source - Copy/command.c **** int append_v9_command(char *buff, char* command) {
 1158              		.loc 1 112 0
 1159 0002 0D1C     		mov	r5, r1
 1160 0004 041C     		mov	r4, r0
 113:../Source - Copy/command.c **** 	strcat(buff, ",V9,");
 1161              		.loc 1 113 0
 1162 0006 0449     		ldr	r1, .L62
 1163              	.LVL98:
 1164 0008 FFF7FEFF 		bl	strcat
 1165              	.LVL99:
 114:../Source - Copy/command.c **** 	strcat(buff, command);
 1166              		.loc 1 114 0
 1167 000c 291C     		mov	r1, r5
 1168 000e 201C     		mov	r0, r4
 1169 0010 FFF7FEFF 		bl	strcat
 1170              		@ sp needed for prologue
 116:../Source - Copy/command.c **** }
 1171              		.loc 1 116 0
 1172 0014 0120     		mov	r0, #1
 1173              	.LVL100:
 1174              	.LVL101:
 1175 0016 38BD     		pop	{r3, r4, r5, pc}
 1176              	.L63:
 1177              		.align	2
 1178              	.L62:
 1179 0018 64000000 		.word	.LC60
 1180              		.cfi_endproc
 1181              	.LFE39:
 1183              		.section	.text.next_char,"ax",%progbits
 1184              		.align	1
 1185              		.global	next_char
 1186              		.code	16
 1187              		.thumb_func
 1189              	next_char:
 1190              	.LFB40:
 118:../Source - Copy/command.c **** int next_char(char* data, char sep, int max) {
 1191              		.loc 1 118 0
 1192              		.cfi_startproc
 1193 0000 38B5     		push	{r3, r4, r5, lr}
 1194              	.LCFI17:
 1195              		.cfi_def_cfa_offset 16
 1196              		.cfi_offset 3, -16
 1197              		.cfi_offset 4, -12
 1198              		.cfi_offset 5, -8
 1199              		.cfi_offset 14, -4
 1200              	.LVL102:
 118:../Source - Copy/command.c **** int next_char(char* data, char sep, int max) {
 1201              		.loc 1 118 0
 1202 0002 041C     		mov	r4, r0
 1203 0004 151C     		mov	r5, r2
 119:../Source - Copy/command.c **** 	char *ptr = strchr(data, sep);
 1204              		.loc 1 119 0
 1205 0006 FFF7FEFF 		bl	strchr
 1206              	.LVL103:
 120:../Source - Copy/command.c **** 	if (ptr) {
 1207              		.loc 1 120 0
 1208 000a 0028     		cmp	r0, #0
 1209 000c 03D0     		beq	.L65
 121:../Source - Copy/command.c **** 		return (ptr - data) >= max ? max : (ptr - data);
 1210              		.loc 1 121 0
 1211 000e 001B     		sub	r0, r0, r4
 1212              	.LVL104:
 1213 0010 A842     		cmp	r0, r5
 1214 0012 00DD     		ble	.L65
 1215 0014 281C     		mov	r0, r5
 1216              	.L65:
 1217              		@ sp needed for prologue
 1218              	.LVL105:
 1219              	.LVL106:
 125:../Source - Copy/command.c **** }
 1220              		.loc 1 125 0
 1221 0016 38BD     		pop	{r3, r4, r5, pc}
 1222              		.cfi_endproc
 1223              	.LFE40:
 1225              		.section	.text.sks_cmd_serial,"ax",%progbits
 1226              		.align	1
 1227              		.code	16
 1228              		.thumb_func
 1230              	sks_cmd_serial:
 1231              	.LFB47:
 310:../Source - Copy/command.c **** static int sks_cmd_serial(int from, char* command, int argc, char** argv, int size, int total) {
 1232              		.loc 1 310 0
 1233              		.cfi_startproc
 1234 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1235              	.LCFI18:
 1236              		.cfi_def_cfa_offset 32
 1237              		.cfi_offset 0, -32
 1238              		.cfi_offset 1, -28
 1239              		.cfi_offset 2, -24
 1240              		.cfi_offset 4, -20
 1241              		.cfi_offset 5, -16
 1242              		.cfi_offset 6, -12
 1243              		.cfi_offset 7, -8
 1244              		.cfi_offset 14, -4
 1245              	.LVL107:
 314:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 1246              		.loc 1 314 0
 1247 0002 1869     		ldr	r0, [r3, #16]
 1248              	.LVL108:
 310:../Source - Copy/command.c **** static int sks_cmd_serial(int from, char* command, int argc, char** argv, int size, int total) {
 1249              		.loc 1 310 0
 1250 0004 0F1C     		mov	r7, r1
 1251 0006 1C1C     		mov	r4, r3
 314:../Source - Copy/command.c **** 	if (argv[4] == NULL)
 1252              		.loc 1 314 0
 1253 0008 0028     		cmp	r0, #0
 1254 000a 24D0     		beq	.L69
 317:../Source - Copy/command.c **** 	set = atoi(argv[4]);
 1255              		.loc 1 317 0
 1256 000c FFF7FEFF 		bl	atoi
 1257              	.LVL109:
 1258 0010 C5B2     		uxtb	r5, r0
 1259              	.LVL110:
 319:../Source - Copy/command.c **** 	if(set == 1) {
 1260              		.loc 1 319 0
 1261 0012 012D     		cmp	r5, #1
 1262 0014 12D1     		bne	.L70
 320:../Source - Copy/command.c **** 		memset(g_config.deviceCode, 0, sizeof(g_config.deviceCode));
 1263              		.loc 1 320 0
 1264 0016 114E     		ldr	r6, .L71
 1265 0018 0021     		mov	r1, #0
 1266 001a 0A22     		mov	r2, #10
 1267 001c 301C     		mov	r0, r6
 1268 001e FFF7FEFF 		bl	memset
 321:../Source - Copy/command.c **** 		strncpy(g_config.deviceCode, argv[5], next_char(argv[5], '#', DEVICE_CODE_LEN));
 1269              		.loc 1 321 0
 1270 0022 6469     		ldr	r4, [r4, #20]
 1271              	.LVL111:
 1272 0024 2321     		mov	r1, #35
 1273 0026 0A22     		mov	r2, #10
 1274 0028 201C     		mov	r0, r4
 1275 002a FFF7FEFF 		bl	next_char
 1276 002e 211C     		mov	r1, r4
 1277 0030 021C     		mov	r2, r0
 1278 0032 301C     		mov	r0, r6
 1279 0034 FFF7FEFF 		bl	strncpy
 323:../Source - Copy/command.c **** 		write_flash = 1;
 1280              		.loc 1 323 0
 1281 0038 094B     		ldr	r3, .L71+4
 1282 003a 1D60     		str	r5, [r3]
 1283              	.L70:
 334:../Source - Copy/command.c **** 	cmd_response(Response, sizeof(Response), command, "%d,%s", set, g_config.deviceCode);
 1284              		.loc 1 334 0
 1285 003c 0095     		str	r5, [sp]
 1286 003e 8021     		mov	r1, #128
 1287 0040 064D     		ldr	r5, .L71
 1288              	.LVL112:
 1289 0042 3A1C     		mov	r2, r7
 1290 0044 0748     		ldr	r0, .L71+8
 1291 0046 4900     		lsl	r1, r1, #1
 1292 0048 074B     		ldr	r3, .L71+12
 1293 004a 0195     		str	r5, [sp, #4]
 1294 004c FFF7FEFF 		bl	cmd_response
 1295              	.LVL113:
 336:../Source - Copy/command.c **** 	response = 1;
 1296              		.loc 1 336 0
 1297 0050 0648     		ldr	r0, .L71+16
 1298 0052 0122     		mov	r2, #1
 1299 0054 0260     		str	r2, [r0]
 1300              	.L69:
 338:../Source - Copy/command.c **** }
 1301              		.loc 1 338 0
 1302 0056 0898     		ldr	r0, [sp, #32]
 1303              		@ sp needed for prologue
 1304              	.LVL114:
 1305 0058 FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 1306              	.L72:
 1307 005a C046     		.align	2
 1308              	.L71:
 1309 005c 02000000 		.word	g_config+2
 1310 0060 00000000 		.word	.LANCHOR3
 1311 0064 00000000 		.word	.LANCHOR1
 1312 0068 69000000 		.word	.LC65
 1313 006c 00000000 		.word	.LANCHOR2
 1314              		.cfi_endproc
 1315              	.LFE47:
 1317              		.section	.text.create_v3,"ax",%progbits
 1318              		.align	1
 1319              		.global	create_v3
 1320              		.code	16
 1321              		.thumb_func
 1323              	create_v3:
 1324              	.LFB41:
 128:../Source - Copy/command.c **** void create_v3(int blockno) {
 1325              		.loc 1 128 0
 1326              		.cfi_startproc
 1327 0000 38B5     		push	{r3, r4, r5, lr}
 1328              	.LCFI19:
 1329              		.cfi_def_cfa_offset 16
 1330              		.cfi_offset 3, -16
 1331              		.cfi_offset 4, -12
 1332              		.cfi_offset 5, -8
 1333              		.cfi_offset 14, -4
 1334              	.LVL115:
 129:../Source - Copy/command.c **** 	append_sign(Response);
 1335              		.loc 1 129 0
 1336 0002 0F4D     		ldr	r5, .L80
 128:../Source - Copy/command.c **** void create_v3(int blockno) {
 1337              		.loc 1 128 0
 1338 0004 041C     		mov	r4, r0
 129:../Source - Copy/command.c **** 	append_sign(Response);
 1339              		.loc 1 129 0
 1340 0006 281C     		mov	r0, r5
 1341              	.LVL116:
 1342 0008 FFF7FEFF 		bl	append_sign
 130:../Source - Copy/command.c **** 	strcat(Response, ",V3,");
 1343              		.loc 1 130 0
 1344 000c 281C     		mov	r0, r5
 1345 000e 0D49     		ldr	r1, .L80+4
 1346 0010 FFF7FEFF 		bl	strcat
 131:../Source - Copy/command.c **** 	if (blockno >= 10000) {
 1347              		.loc 1 131 0
 1348 0014 0C4B     		ldr	r3, .L80+8
 1349 0016 9C42     		cmp	r4, r3
 1350 0018 02DD     		ble	.L74
 132:../Source - Copy/command.c **** 		append_int(Response, 5, blockno);
 1351              		.loc 1 132 0
 1352 001a 281C     		mov	r0, r5
 1353 001c 0521     		mov	r1, #5
 1354 001e 0BE0     		b	.L79
 1355              	.L74:
 133:../Source - Copy/command.c **** 	} else if (blockno >= 1000) {
 1356              		.loc 1 133 0
 1357 0020 0A4A     		ldr	r2, .L80+12
 134:../Source - Copy/command.c **** 		append_int(Response, 4, blockno);
 1358              		.loc 1 134 0
 1359 0022 281C     		mov	r0, r5
 1360 0024 0421     		mov	r1, #4
 133:../Source - Copy/command.c **** 	} else if (blockno >= 1000) {
 1361              		.loc 1 133 0
 1362 0026 9442     		cmp	r4, r2
 1363 0028 06DC     		bgt	.L79
 136:../Source - Copy/command.c **** 		append_int(Response, 3, blockno);
 1364              		.loc 1 136 0
 1365 002a 0321     		mov	r1, #3
 135:../Source - Copy/command.c **** 	} else if (blockno >= 100) {
 1366              		.loc 1 135 0
 1367 002c 632C     		cmp	r4, #99
 1368 002e 03DC     		bgt	.L79
 138:../Source - Copy/command.c **** 		append_int(Response, 2, blockno);
 1369              		.loc 1 138 0
 1370 0030 0221     		mov	r1, #2
 137:../Source - Copy/command.c **** 	} else if (blockno >= 10) {
 1371              		.loc 1 137 0
 1372 0032 092C     		cmp	r4, #9
 1373 0034 00DC     		bgt	.L79
 140:../Source - Copy/command.c **** 		append_int(Response, 1, blockno);
 1374              		.loc 1 140 0
 1375 0036 0121     		mov	r1, #1
 1376              	.L79:
 1377 0038 221C     		mov	r2, r4
 1378 003a FFF7FEFF 		bl	append_int
 1379              		@ sp needed for prologue
 1380              	.LVL117:
 142:../Source - Copy/command.c **** }
 1381              		.loc 1 142 0
 1382 003e 38BD     		pop	{r3, r4, r5, pc}
 1383              	.L81:
 1384              		.align	2
 1385              	.L80:
 1386 0040 00000000 		.word	.LANCHOR1
 1387 0044 6F000000 		.word	.LC69
 1388 0048 0F270000 		.word	9999
 1389 004c E7030000 		.word	999
 1390              		.cfi_endproc
 1391              	.LFE41:
 1393              		.global	__aeabi_idivmod
 1394              		.section	.text.server_on_command,"ax",%progbits
 1395              		.align	1
 1396              		.global	server_on_command
 1397              		.code	16
 1398              		.thumb_func
 1400              	server_on_command:
 1401              	.LFB50:
 377:../Source - Copy/command.c **** 
 378:../Source - Copy/command.c **** SKS_HANDLER handlers[] = {
 379:../Source - Copy/command.c **** 		{ "CFG", sks_cmd_config }, //get config
 380:../Source - Copy/command.c **** 		{ "INFO", sks_cmd_info }, //get config
 381:../Source - Copy/command.c **** 		{ "INTERVAL", sks_cmd_interval }, //get config
 382:../Source - Copy/command.c **** 		{ "SN", sks_cmd_serial }, //set serial
 383:../Source - Copy/command.c **** 		{ "RESET", sks_cmd_reset }, //set serial
 384:../Source - Copy/command.c **** 		{ "SF", sks_cmd_set_full }, //get config
 385:../Source - Copy/command.c **** 		{ "SE", sks_cmd_set_empty }, //get config
 386:../Source - Copy/command.c **** 		{ "DEBUG", sks_cmd_set_debug }, //get config
 387:../Source - Copy/command.c **** 		{ NULL, NULL } };
 388:../Source - Copy/command.c **** 
 389:../Source - Copy/command.c **** int server_on_command(int from, char* data, int size) {
 1402              		.loc 1 389 0
 1403              		.cfi_startproc
 1404 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1405              	.LCFI20:
 1406              		.cfi_def_cfa_offset 20
 1407              		.cfi_offset 4, -20
 1408              		.cfi_offset 5, -16
 1409              		.cfi_offset 6, -12
 1410              		.cfi_offset 7, -8
 1411              		.cfi_offset 14, -4
 1412              	.LVL118:
 1413 0002 A5B0     		sub	sp, sp, #148
 1414              	.LCFI21:
 1415              		.cfi_def_cfa_offset 168
 1416              	.LVL119:
 1417              		.loc 1 389 0
 1418 0004 0690     		str	r0, [sp, #24]
 1419 0006 0591     		str	r1, [sp, #20]
 1420 0008 0792     		str	r2, [sp, #28]
 390:../Source - Copy/command.c **** 	#define SKS_MAX_CMD_LEN 10
 391:../Source - Copy/command.c **** 	#define SKS_MAX_ARGV 	25
 392:../Source - Copy/command.c **** 	int result = 0;
 393:../Source - Copy/command.c **** 	int field = 0;
 394:../Source - Copy/command.c **** 	int ftmp;
 395:../Source - Copy/command.c **** 	int j = 0;
 396:../Source - Copy/command.c **** 	char *ptr = data;
 397:../Source - Copy/command.c **** 
 398:../Source - Copy/command.c **** 	char command[SKS_MAX_CMD_LEN + 1] = { 0 };
 1421              		.loc 1 398 0
 1422 000a 21A8     		add	r0, sp, #132
 1423              	.LVL120:
 1424 000c 0021     		mov	r1, #0
 1425              	.LVL121:
 1426 000e 0B22     		mov	r2, #11
 1427              	.LVL122:
 1428 0010 FFF7FEFF 		bl	memset
 1429              	.LVL123:
 399:../Source - Copy/command.c **** 
 400:../Source - Copy/command.c **** 	int endPos = 0;
 401:../Source - Copy/command.c **** 	int i = 0;
 402:../Source - Copy/command.c **** 	char item_buff[20] = { 0 };
 403:../Source - Copy/command.c **** 	char* arg[SKS_MAX_ARGV];
 404:../Source - Copy/command.c **** 	for (i = 0; i < size; i++) {
 1430              		.loc 1 404 0
 1431 0014 0026     		mov	r6, #0
 1432 0016 13E0     		b	.L83
 1433              	.LVL124:
 1434              	.L88:
 405:../Source - Copy/command.c **** 		if ((data[i] == '#') || (data[i] == '\n') || (data[i] == '\0')) {
 1435              		.loc 1 405 0
 1436 0018 059A     		ldr	r2, [sp, #20]
 1437 001a 935D     		ldrb	r3, [r2, r6]
 1438 001c 0A2B     		cmp	r3, #10
 1439 001e 03D0     		beq	.L84
 1440 0020 232B     		cmp	r3, #35
 1441 0022 01D0     		beq	.L84
 1442              		.loc 1 405 0 is_stmt 0 discriminator 1
 1443 0024 002B     		cmp	r3, #0
 1444 0026 0AD1     		bne	.L85
 1445              	.L84:
 406:../Source - Copy/command.c **** 			endPos = i + 1;
 1446              		.loc 1 406 0 is_stmt 1
 1447 0028 0136     		add	r6, r6, #1
 1448              	.LVL125:
 407:../Source - Copy/command.c **** 			break;
 408:../Source - Copy/command.c **** 		}
 409:../Source - Copy/command.c **** 	}
 410:../Source - Copy/command.c **** 
 411:../Source - Copy/command.c **** 	//xprintf("come here: %d\r\n", 1);
 412:../Source - Copy/command.c **** 
 413:../Source - Copy/command.c **** 	if (endPos == 0)
 1449              		.loc 1 413 0
 1450 002a 002E     		cmp	r6, #0
 1451 002c 00D1     		bne	.LCB1241
 1452 002e 9EE0     		b	.L86	@long jump
 1453              	.LCB1241:
 1454 0030 059B     		ldr	r3, [sp, #20]
 1455 0032 0024     		mov	r4, #0
 1456 0034 0493     		str	r3, [sp, #16]
 1457 0036 1F1C     		mov	r7, r3
 1458 0038 0394     		str	r4, [sp, #12]
 1459 003a 251C     		mov	r5, r4
 1460 003c 4EE0     		b	.L87
 1461              	.LVL126:
 1462              	.L85:
 404:../Source - Copy/command.c **** 	for (i = 0; i < size; i++) {
 1463              		.loc 1 404 0
 1464 003e 0136     		add	r6, r6, #1
 1465              	.LVL127:
 1466              	.L83:
 404:../Source - Copy/command.c **** 	for (i = 0; i < size; i++) {
 1467              		.loc 1 404 0 is_stmt 0 discriminator 1
 1468 0040 0798     		ldr	r0, [sp, #28]
 1469 0042 8642     		cmp	r6, r0
 1470 0044 E8DB     		blt	.L88
 414:../Source - Copy/command.c **** 		return 0; //Waiting for end command sign
 1471              		.loc 1 414 0 is_stmt 1
 1472 0046 0026     		mov	r6, #0
 1473              	.LVL128:
 1474 0048 91E0     		b	.L86
 1475              	.LVL129:
 1476              	.L98:
 1477              	.LBB4:
 415:../Source - Copy/command.c **** 
 416:../Source - Copy/command.c **** 	//xprintf("come here: %d, endPos: %d\r\n", 2, endPos);
 417:../Source - Copy/command.c **** 
 418:../Source - Copy/command.c **** 	for (int i = 0; i < endPos; i++) {
 419:../Source - Copy/command.c **** 		if ((data[i] == ',') || (data[i] == '\n') || (data[i] == '#') || (data[i] == 0x00)) //complete on
 1478              		.loc 1 419 0
 1479 004a 059A     		ldr	r2, [sp, #20]
 1480 004c 0499     		ldr	r1, [sp, #16]
 1481 004e 135D     		ldrb	r3, [r2, r4]
 1482 0050 0131     		add	r1, r1, #1
 1483 0052 0491     		str	r1, [sp, #16]
 1484 0054 0A2B     		cmp	r3, #10
 1485 0056 05D0     		beq	.L89
 1486 0058 2C2B     		cmp	r3, #44
 1487 005a 03D0     		beq	.L89
 1488              		.loc 1 419 0 is_stmt 0 discriminator 1
 1489 005c 232B     		cmp	r3, #35
 1490 005e 01D0     		beq	.L89
 1491 0060 002B     		cmp	r3, #0
 1492 0062 37D1     		bne	.L90
 1493              	.L89:
 420:../Source - Copy/command.c **** 		{
 421:../Source - Copy/command.c **** 			//xprintf("FIELD0 %d j=%d DATA %s\r\n", field, j, item_buff);
 422:../Source - Copy/command.c **** 
 423:../Source - Copy/command.c **** 			if (j > 0) {
 1494              		.loc 1 423 0 is_stmt 1
 1495 0064 039B     		ldr	r3, [sp, #12]
 1496 0066 002B     		cmp	r3, #0
 1497 0068 26D0     		beq	.L91
 424:../Source - Copy/command.c **** 				//xprintf("FIELD1 %d DATA %s, ptr=%s\r\n", field, item_buff, ptr);
 425:../Source - Copy/command.c **** 
 426:../Source - Copy/command.c **** 				//if(*(uint32_t*)(ptr) == 0x2C53532A) //*SS,
 427:../Source - Copy/command.c **** 				if(strncmp(ptr, "*SS,", 4) == 0) //*SS,
 1498              		.loc 1 427 0
 1499 006a 381C     		mov	r0, r7
 1500 006c 4149     		ldr	r1, .L110
 1501 006e 0422     		mov	r2, #4
 1502 0070 FFF7FEFF 		bl	strncmp
 1503 0074 0028     		cmp	r0, #0
 1504 0076 00D1     		bne	.L92
 428:../Source - Copy/command.c **** 				{
 429:../Source - Copy/command.c **** 					field = 0;
 1505              		.loc 1 429 0
 1506 0078 051C     		mov	r5, r0
 1507              	.LVL130:
 1508              	.L92:
 430:../Source - Copy/command.c **** 				}
 431:../Source - Copy/command.c **** 				ftmp = field;
 432:../Source - Copy/command.c **** 
 433:../Source - Copy/command.c **** 				//xprintf("FIELD %d DATA %s\r\n", field, item_buff);
 434:../Source - Copy/command.c **** 
 435:../Source - Copy/command.c **** 				arg[field % SKS_MAX_ARGV] = ptr;
 1509              		.loc 1 435 0
 1510 007a 281C     		mov	r0, r5
 1511 007c 1921     		mov	r1, #25
 1512 007e FFF7FEFF 		bl	__aeabi_idivmod
 1513 0082 8800     		lsl	r0, r1, #2
 1514 0084 08A9     		add	r1, sp, #32
 1515 0086 4750     		str	r7, [r0, r1]
 436:../Source - Copy/command.c **** 				switch (ftmp) {
 1516              		.loc 1 436 0
 1517 0088 002D     		cmp	r5, #0
 1518 008a 02D0     		beq	.L93
 1519 008c 022D     		cmp	r5, #2
 1520 008e 13D1     		bne	.L91
 1521 0090 08E0     		b	.L109
 1522              	.L93:
 437:../Source - Copy/command.c **** 				case 0:
 438:../Source - Copy/command.c **** 					if(strncmp(ptr, "*SS,", 4) != 0) //*SS,
 1523              		.loc 1 438 0
 1524 0092 381C     		mov	r0, r7
 1525 0094 3749     		ldr	r1, .L110
 1526 0096 0422     		mov	r2, #4
 1527 0098 FFF7FEFF 		bl	strncmp
 1528 009c 0028     		cmp	r0, #0
 1529 009e 64D1     		bne	.L105
 1530 00a0 0125     		mov	r5, #1
 1531              	.LVL131:
 1532 00a2 0CE0     		b	.L108
 1533              	.LVL132:
 1534              	.L109:
 439:../Source - Copy/command.c **** 						return -1; //*SS,
 440:../Source - Copy/command.c **** 					break;
 441:../Source - Copy/command.c **** 				case 1:
 442:../Source - Copy/command.c **** 					break;
 443:../Source - Copy/command.c **** 				case 2:
 444:../Source - Copy/command.c **** 					memcpy(command, ptr, j < SKS_MAX_CMD_LEN ? j : SKS_MAX_CMD_LEN);
 1535              		.loc 1 444 0
 1536 00a4 039A     		ldr	r2, [sp, #12]
 1537 00a6 0A2A     		cmp	r2, #10
 1538 00a8 00DD     		ble	.L95
 1539 00aa 0A22     		mov	r2, #10
 1540              	.L95:
 1541 00ac 21A8     		add	r0, sp, #132
 1542 00ae 391C     		mov	r1, r7
 1543 00b0 FFF7FEFF 		bl	memcpy
 1544 00b4 0325     		mov	r5, #3
 1545              	.LVL133:
 445:../Source - Copy/command.c **** 					break;
 1546              		.loc 1 445 0
 1547 00b6 02E0     		b	.L108
 1548              	.LVL134:
 1549              	.L91:
 446:../Source - Copy/command.c **** 				case 3:
 447:../Source - Copy/command.c **** 					break;
 448:../Source - Copy/command.c **** 				default:
 449:../Source - Copy/command.c **** 					break;
 450:../Source - Copy/command.c **** 				}
 451:../Source - Copy/command.c **** 			}
 452:../Source - Copy/command.c **** 
 453:../Source - Copy/command.c **** 			field++;
 1550              		.loc 1 453 0
 1551 00b8 0135     		add	r5, r5, #1
 1552              	.LVL135:
 454:../Source - Copy/command.c **** 			if (field >= SKS_MAX_ARGV)
 1553              		.loc 1 454 0
 1554 00ba 182D     		cmp	r5, #24
 1555 00bc 10DC     		bgt	.L96
 1556              	.LVL136:
 1557              	.L108:
 455:../Source - Copy/command.c **** 				break;
 456:../Source - Copy/command.c **** 
 457:../Source - Copy/command.c **** 			j = 0; //reset index
 458:../Source - Copy/command.c **** 			ptr = data + i + 1;
 459:../Source - Copy/command.c **** 			arg[field % SKS_MAX_ARGV] = ptr;
 1558              		.loc 1 459 0
 1559 00be 281C     		mov	r0, r5
 1560 00c0 1921     		mov	r1, #25
 1561 00c2 FFF7FEFF 		bl	__aeabi_idivmod
 1562 00c6 049F     		ldr	r7, [sp, #16]
 1563 00c8 8800     		lsl	r0, r1, #2
 1564 00ca 08AB     		add	r3, sp, #32
 457:../Source - Copy/command.c **** 			j = 0; //reset index
 1565              		.loc 1 457 0
 1566 00cc 0022     		mov	r2, #0
 1567              		.loc 1 459 0
 1568 00ce C750     		str	r7, [r0, r3]
 457:../Source - Copy/command.c **** 			j = 0; //reset index
 1569              		.loc 1 457 0
 1570 00d0 0392     		str	r2, [sp, #12]
 1571              		.loc 1 459 0
 1572 00d2 02E0     		b	.L97
 1573              	.LVL137:
 1574              	.L90:
 460:../Source - Copy/command.c **** 		} else {
 461:../Source - Copy/command.c **** 			item_buff[j % sizeof(item_buff)] = data[i];
 462:../Source - Copy/command.c **** 			j++;
 1575              		.loc 1 462 0
 1576 00d4 0399     		ldr	r1, [sp, #12]
 1577 00d6 0131     		add	r1, r1, #1
 1578 00d8 0391     		str	r1, [sp, #12]
 1579              	.LVL138:
 1580              	.L97:
 418:../Source - Copy/command.c **** 	for (int i = 0; i < endPos; i++) {
 1581              		.loc 1 418 0
 1582 00da 0134     		add	r4, r4, #1
 1583              	.LVL139:
 1584              	.L87:
 418:../Source - Copy/command.c **** 	for (int i = 0; i < endPos; i++) {
 1585              		.loc 1 418 0 is_stmt 0 discriminator 1
 1586 00dc B442     		cmp	r4, r6
 1587 00de B4DB     		blt	.L98
 1588              	.L96:
 1589              	.LBE4:
 463:../Source - Copy/command.c **** 			item_buff[j] = 0x00;
 464:../Source - Copy/command.c **** 
 465:../Source - Copy/command.c **** 			//xprintf("Item buff %s\r\n", item_buff);
 466:../Source - Copy/command.c **** 		}
 467:../Source - Copy/command.c **** 	}
 468:../Source - Copy/command.c **** 
 469:../Source - Copy/command.c **** 	//xprintf("come here: %d\r\n", 3);
 470:../Source - Copy/command.c **** 
 471:../Source - Copy/command.c **** 	if (field > SKS_MAX_ARGV)
 1590              		.loc 1 471 0 is_stmt 1
 1591 00e0 192D     		cmp	r5, #25
 1592 00e2 44DC     		bgt	.L86
 472:../Source - Copy/command.c **** 		return endPos; //Too many param
 473:../Source - Copy/command.c **** 
 474:../Source - Copy/command.c **** 	//xprintf("come here: %d\r\n", 4);
 475:../Source - Copy/command.c **** 
 476:../Source - Copy/command.c **** 	if (field <= 3)
 1593              		.loc 1 476 0
 1594 00e4 032D     		cmp	r5, #3
 1595 00e6 42DD     		ble	.L86
 1596              	.LVL140:
 477:../Source - Copy/command.c **** 		return endPos; //Too few param
 478:../Source - Copy/command.c **** 
 479:../Source - Copy/command.c **** 	//xprintf("server_on_command: %s, command: %s \r\n", data, command);
 480:../Source - Copy/command.c **** 
 481:../Source - Copy/command.c **** 	i = 0;
 482:../Source - Copy/command.c **** 	result = -1;
 483:../Source - Copy/command.c **** 	response = 0;
 1597              		.loc 1 483 0
 1598 00e8 234C     		ldr	r4, .L110+4
 1599              	.LVL141:
 1600 00ea 0027     		mov	r7, #0
 1601              	.LVL142:
 1602 00ec 2760     		str	r7, [r4]
 1603 00ee 234C     		ldr	r4, .L110+8
 484:../Source - Copy/command.c **** 	while(handlers[i].cmd) {
 1604              		.loc 1 484 0
 1605 00f0 25E0     		b	.L99
 1606              	.LVL143:
 1607              	.L102:
 485:../Source - Copy/command.c **** 		if (strcmp(command, handlers[i].cmd) == 0) {
 1608              		.loc 1 485 0
 1609 00f2 21A8     		add	r0, sp, #132
 1610 00f4 FFF7FEFF 		bl	strcmp
 1611 00f8 0C34     		add	r4, r4, #12
 1612 00fa 0028     		cmp	r0, #0
 1613 00fc 1ED1     		bne	.L100
 486:../Source - Copy/command.c **** 			//sks_log(LOG_INFO, "COMMAND A %s handlers[%d].cmd=%s", command, i, handlers[i].cmd);
 487:../Source - Copy/command.c **** 			if (!(handlers[i].dis_mask & from)) //Chi cho phep gui lenh tu nguon
 1614              		.loc 1 487 0
 1615 00fe 0C20     		mov	r0, #12
 1616 0100 4743     		mul	r7, r0
 1617              	.LVL144:
 1618 0102 1E4A     		ldr	r2, .L110+8
 1619 0104 D419     		add	r4, r2, r7
 1620 0106 2189     		ldrh	r1, [r4, #8]
 1621 0108 069F     		ldr	r7, [sp, #24]
 1622 010a 3940     		and	r1, r7
 1623 010c 2FD1     		bne	.L86
 488:../Source - Copy/command.c **** 			{
 489:../Source - Copy/command.c **** 				write_flash = 0;
 1624              		.loc 1 489 0
 1625 010e 1C4F     		ldr	r7, .L110+12
 490:../Source - Copy/command.c **** 				memset(Response, 0, 200);
 1626              		.loc 1 490 0
 1627 0110 C822     		mov	r2, #200
 489:../Source - Copy/command.c **** 				write_flash = 0;
 1628              		.loc 1 489 0
 1629 0112 3960     		str	r1, [r7]
 1630              		.loc 1 490 0
 1631 0114 1B48     		ldr	r0, .L110+16
 1632 0116 FFF7FEFF 		bl	memset
 491:../Source - Copy/command.c **** 
 492:../Source - Copy/command.c **** 				result = handlers[i].handler(from, command, field, arg, endPos, size);
 1633              		.loc 1 492 0
 1634 011a 0799     		ldr	r1, [sp, #28]
 1635 011c 0096     		str	r6, [sp]
 1636 011e 0191     		str	r1, [sp, #4]
 1637 0120 6468     		ldr	r4, [r4, #4]
 1638 0122 2A1C     		mov	r2, r5
 1639 0124 08AB     		add	r3, sp, #32
 1640 0126 0698     		ldr	r0, [sp, #24]
 1641 0128 21A9     		add	r1, sp, #132
 1642 012a A047     		blx	r4
 493:../Source - Copy/command.c **** 				//sks_log(LOG_INFO, "***********===************COMMAND B%s handlers[%d].cmd=%s, total %d result
 494:../Source - Copy/command.c **** 
 495:../Source - Copy/command.c **** 				if(write_flash) {
 1643              		.loc 1 495 0
 1644 012c 3B68     		ldr	r3, [r7]
 492:../Source - Copy/command.c **** 				result = handlers[i].handler(from, command, field, arg, endPos, size);
 1645              		.loc 1 492 0
 1646 012e 041C     		mov	r4, r0
 1647              	.LVL145:
 1648 0130 144D     		ldr	r5, .L110+16
 1649              	.LVL146:
 1650              		.loc 1 495 0
 1651 0132 002B     		cmp	r3, #0
 1652 0134 07D0     		beq	.L101
 496:../Source - Copy/command.c **** 					write_config();
 1653              		.loc 1 496 0
 1654 0136 FFF7FEFF 		bl	write_config
 1655              	.LVL147:
 1656 013a 04E0     		b	.L101
 1657              	.LVL148:
 1658              	.L100:
 497:../Source - Copy/command.c **** 				}
 498:../Source - Copy/command.c **** 			}
 499:../Source - Copy/command.c **** 			break;
 500:../Source - Copy/command.c **** 		}
 501:../Source - Copy/command.c **** 		i++;
 1659              		.loc 1 501 0
 1660 013c 0137     		add	r7, r7, #1
 1661              	.LVL149:
 1662              	.L99:
 484:../Source - Copy/command.c **** 	while(handlers[i].cmd) {
 1663              		.loc 1 484 0 discriminator 1
 1664 013e 2168     		ldr	r1, [r4]
 1665 0140 0029     		cmp	r1, #0
 1666 0142 D6D1     		bne	.L102
 1667 0144 13E0     		b	.L86
 1668              	.LVL150:
 1669              	.L101:
 502:../Source - Copy/command.c **** 	}
 503:../Source - Copy/command.c **** 
 504:../Source - Copy/command.c **** 	if (result > 0) {
 1670              		.loc 1 504 0
 1671 0146 002C     		cmp	r4, #0
 1672 0148 0BDD     		ble	.L103
 505:../Source - Copy/command.c **** 		if (response) {
 1673              		.loc 1 505 0
 1674 014a 0B4E     		ldr	r6, .L110+4
 1675              	.LVL151:
 1676 014c 3268     		ldr	r2, [r6]
 1677 014e 261C     		mov	r6, r4
 1678 0150 002A     		cmp	r2, #0
 1679 0152 0CD0     		beq	.L86
 506:../Source - Copy/command.c **** 			if (from == SKS_CMD_SOURCE_COM1) {
 1680              		.loc 1 506 0
 1681 0154 0698     		ldr	r0, [sp, #24]
 1682 0156 0128     		cmp	r0, #1
 1683 0158 09D1     		bne	.L86
 507:../Source - Copy/command.c **** 				xprintf(Response);
 1684              		.loc 1 507 0
 1685 015a 281C     		mov	r0, r5
 1686 015c FFF7FEFF 		bl	xprintf
 1687 0160 05E0     		b	.L86
 1688              	.LVL152:
 1689              	.L103:
 508:../Source - Copy/command.c **** 			} else if (from == SKS_CMD_SOURCE_COM2) {
 509:../Source - Copy/command.c **** 				//ExtSerial_PutString(Response);
 510:../Source - Copy/command.c **** 			} else {
 511:../Source - Copy/command.c **** 			}
 512:../Source - Copy/command.c **** 		}
 513:../Source - Copy/command.c **** 	} else if (result < 0) {
 1690              		.loc 1 513 0
 1691 0162 002C     		cmp	r4, #0
 1692 0164 03D1     		bne	.L86
 1693 0166 261C     		mov	r6, r4
 1694              	.LVL153:
 1695 0168 01E0     		b	.L86
 1696              	.LVL154:
 1697              	.L105:
 1698              	.LBB5:
 439:../Source - Copy/command.c **** 						return -1; //*SS,
 1699              		.loc 1 439 0
 1700 016a 0125     		mov	r5, #1
 1701              	.LVL155:
 1702 016c 6E42     		neg	r6, r5
 1703              	.LVL156:
 1704              	.L86:
 1705              	.LBE5:
 514:../Source - Copy/command.c **** 		result = endPos;
 515:../Source - Copy/command.c **** 	}
 516:../Source - Copy/command.c **** 
 517:../Source - Copy/command.c **** 	return result;
 518:../Source - Copy/command.c **** }
 1706              		.loc 1 518 0
 1707 016e 301C     		mov	r0, r6
 1708 0170 25B0     		add	sp, sp, #148
 1709              		@ sp needed for prologue
 1710 0172 F0BD     		pop	{r4, r5, r6, r7, pc}
 1711              	.L111:
 1712              		.align	2
 1713              	.L110:
 1714 0174 59000000 		.word	.LC51
 1715 0178 00000000 		.word	.LANCHOR2
 1716 017c 00000000 		.word	.LANCHOR4
 1717 0180 00000000 		.word	.LANCHOR3
 1718 0184 00000000 		.word	.LANCHOR1
 1719              		.cfi_endproc
 1720              	.LFE50:
 1722              		.global	handlers
 1723              		.global	write_flash
 1724              		.global	HexChar
 1725              		.comm	g_appStats,136,4
 1726              		.comm	g_config,28,4
 1727              		.section	.bss.Response,"aw",%nobits
 1728              		.set	.LANCHOR1,. + 0
 1731              	Response:
 1732 0000 00000000 		.space	256
 1732      00000000 
 1732      00000000 
 1732      00000000 
 1732      00000000 
 1733              		.section	.rodata.str1.1,"aMS",%progbits,1
 1734              	.LC2:
 1735 0000 2A53532C 		.ascii	"*SS,%s,V9,%s,\000"
 1735      25732C56 
 1735      392C2573 
 1735      2C00
 1736              	.LC7:
 1737 000e 25642C25 		.ascii	"%d,%d\000"
 1737      6400
 1738              	.LC15:
 1739 0014 25642C25 		.ascii	"%d,%d,%d\000"
 1739      642C2564 
 1739      00
 1740              	.LC29:
 1741 001d 256400   		.ascii	"%d\000"
 1742              	.LC38:
 1743 0020 25642C25 		.ascii	"%d,%d,%d,%d,%d,%s,%s\000"
 1743      642C2564 
 1743      2C25642C 
 1743      25642C25 
 1743      732C2573 
 1744              	.LC42:
 1745 0035 4C4C5333 		.ascii	"LLS3.0.10F0-20221004\000"
 1745      2E302E31 
 1745      3046302D 
 1745      32303232 
 1745      31303034 
 1746              	.LC48:
 1747 004a 25642C25 		.ascii	"%d,%d,%d,%d,%d\000"
 1747      642C2564 
 1747      2C25642C 
 1747      256400
 1748              	.LC51:
 1749 0059 2A53532C 		.ascii	"*SS,\000"
 1749      00
 1750              	.LC54:
 1751 005e 2D00     		.ascii	"-\000"
 1752              	.LC56:
 1753 0060 2000     		.ascii	" \000"
 1754              	.LC58:
 1755 0062 3A00     		.ascii	":\000"
 1756              	.LC60:
 1757 0064 2C56392C 		.ascii	",V9,\000"
 1757      00
 1758              	.LC65:
 1759 0069 25642C25 		.ascii	"%d,%s\000"
 1759      7300
 1760              	.LC69:
 1761 006f 2C56332C 		.ascii	",V3,\000"
 1761      00
 1762              	.LC79:
 1763 0074 43464700 		.ascii	"CFG\000"
 1764              	.LC80:
 1765 0078 494E464F 		.ascii	"INFO\000"
 1765      00
 1766              	.LC81:
 1767 007d 494E5445 		.ascii	"INTERVAL\000"
 1767      5256414C 
 1767      00
 1768              	.LC82:
 1769 0086 534E00   		.ascii	"SN\000"
 1770              	.LC83:
 1771 0089 52455345 		.ascii	"RESET\000"
 1771      5400
 1772              	.LC84:
 1773 008f 534600   		.ascii	"SF\000"
 1774              	.LC85:
 1775 0092 534500   		.ascii	"SE\000"
 1776              	.LC86:
 1777 0095 44454255 		.ascii	"DEBUG\000"
 1777      4700
 1778              	.LC87:
 1779 009b 31323334 		.ascii	"1234567890ABCDEF\000"
 1779      35363738 
 1779      39304142 
 1779      43444546 
 1779      00
 1780              		.section	.bss.write_flash,"aw",%nobits
 1781              		.align	2
 1782              		.set	.LANCHOR3,. + 0
 1785              	write_flash:
 1786 0000 00000000 		.space	4
 1787              		.section	.bss.response,"aw",%nobits
 1788              		.align	2
 1789              		.set	.LANCHOR2,. + 0
 1792              	response:
 1793 0000 00000000 		.space	4
 1794              		.section	.data.handlers,"aw",%progbits
 1795              		.align	2
 1796              		.set	.LANCHOR4,. + 0
 1799              	handlers:
 1800 0000 74000000 		.word	.LC79
 1801 0004 00000000 		.word	sks_cmd_config
 1802 0008 00000000 		.space	4
 1803 000c 78000000 		.word	.LC80
 1804 0010 00000000 		.word	sks_cmd_info
 1805 0014 00000000 		.space	4
 1806 0018 7D000000 		.word	.LC81
 1807 001c 00000000 		.word	sks_cmd_interval
 1808 0020 00000000 		.space	4
 1809 0024 86000000 		.word	.LC82
 1810 0028 00000000 		.word	sks_cmd_serial
 1811 002c 00000000 		.space	4
 1812 0030 89000000 		.word	.LC83
 1813 0034 00000000 		.word	sks_cmd_reset
 1814 0038 00000000 		.space	4
 1815 003c 8F000000 		.word	.LC84
 1816 0040 00000000 		.word	sks_cmd_set_full
 1817 0044 00000000 		.space	4
 1818 0048 92000000 		.word	.LC85
 1819 004c 00000000 		.word	sks_cmd_set_empty
 1820 0050 00000000 		.space	4
 1821 0054 95000000 		.word	.LC86
 1822 0058 00000000 		.word	sks_cmd_set_debug
 1823 005c 00000000 		.space	4
 1824 0060 00000000 		.word	0
 1825 0064 00000000 		.word	0
 1826 0068 00000000 		.space	4
 1827              		.section	.data.HexChar,"aw",%progbits
 1828              		.align	2
 1829              		.set	.LANCHOR0,. + 0
 1832              	HexChar:
 1833 0000 9B000000 		.word	.LC87
 1834              		.text
 1835              	.Letext0:
 1836              		.file 2 "c:\\eclipseindigo\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 1837              		.file 3 "c:\\eclipseindigo\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 1838              		.file 4 "c:\\eclipseindigo\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 1839              		.file 5 "c:\\eclipseindigo\\codesourcery\\sourcery_codebench_lite_for_arm_eabi\\bin\\../lib/gcc/ar
 1840              		.file 6 "<built-in>"
 1841              		.file 7 "../Source - Copy/DataUtil.h"
DEFINED SYMBOLS
                            *ABS*:00000000 command.c
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:20     .text.append_int:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:25     .text.append_int:00000000 append_int
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:98     .text.append_hex:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:103    .text.append_hex:00000000 append_hex
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:151    .text.append_hex:00000028 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:156    .text.append_hex_long:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:161    .text.append_hex_long:00000000 append_hex_long
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:251    .text.append_hex_long:0000005c $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:256    .text.cmd_response:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:261    .text.cmd_response:00000000 cmd_response
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:340    .text.cmd_response:00000044 $d
                            *COM*:0000001c g_config
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:346    .text.sks_cmd_set_debug:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:350    .text.sks_cmd_set_debug:00000000 sks_cmd_set_debug
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:407    .text.sks_cmd_set_debug:00000034 $d
                            *COM*:00000088 g_appStats
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:415    .text.sks_cmd_set_empty:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:419    .text.sks_cmd_set_empty:00000000 sks_cmd_set_empty
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:505    .text.sks_cmd_set_empty:00000060 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:515    .text.sks_cmd_set_full:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:519    .text.sks_cmd_set_full:00000000 sks_cmd_set_full
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:605    .text.sks_cmd_set_full:00000060 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:615    .text.sks_cmd_reset:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:619    .text.sks_cmd_reset:00000000 sks_cmd_reset
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:676    .text.sks_cmd_reset:00000038 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:685    .text.sks_cmd_interval:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:689    .text.sks_cmd_interval:00000000 sks_cmd_interval
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:763    .text.sks_cmd_interval:00000050 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:772    .text.sks_cmd_info:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:776    .text.sks_cmd_info:00000000 sks_cmd_info
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:840    .text.sks_cmd_info:0000004c $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:849    .text.sks_cmd_config:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:853    .text.sks_cmd_config:00000000 sks_cmd_config
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:981    .text.sks_cmd_config:00000090 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:990    .text.append_sign:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:995    .text.append_sign:00000000 append_sign
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1023   .text.append_sign:00000018 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1029   .text.append_time:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1034   .text.append_time:00000000 append_time
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1133   .text.append_time:00000088 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1141   .text.append_v9_command:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1146   .text.append_v9_command:00000000 append_v9_command
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1179   .text.append_v9_command:00000018 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1184   .text.next_char:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1189   .text.next_char:00000000 next_char
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1226   .text.sks_cmd_serial:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1230   .text.sks_cmd_serial:00000000 sks_cmd_serial
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1309   .text.sks_cmd_serial:0000005c $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1318   .text.create_v3:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1323   .text.create_v3:00000000 create_v3
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1386   .text.create_v3:00000040 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1395   .text.server_on_command:00000000 $t
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1400   .text.server_on_command:00000000 server_on_command
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1714   .text.server_on_command:00000174 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1799   .data.handlers:00000000 handlers
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1785   .bss.write_flash:00000000 write_flash
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1832   .data.HexChar:00000000 HexChar
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1731   .bss.Response:00000000 Response
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1732   .bss.Response:00000000 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1781   .bss.write_flash:00000000 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1788   .bss.response:00000000 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1792   .bss.response:00000000 response
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1795   .data.handlers:00000000 $d
C:\Users\khanh\AppData\Local\Temp\ccUbsdiB.s:1828   .data.HexChar:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_uidivmod
__aeabi_uidiv
strlen
usnprintf
uvsnprintf
atoi
raise_command_coming
ulSecCount
strcpy
strcat
gmtime
strchr
memset
strncpy
__aeabi_idivmod
strncmp
memcpy
strcmp
write_config
xprintf
